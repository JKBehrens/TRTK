<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Transformation and Registration Toolkit: TRTK::Optimization Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<script src="../mathjax/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespace_t_r_t_k.html">TRTK</a>      </li>
      <li><a class="el" href="namespace_t_r_t_k_1_1_optimization.html">Optimization</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>TRTK::Optimization Namespace Reference</h1>  </div>
</div>
<div class="contents">

<p>This namespace contains various classes and functions to find the roots (zeros) or the local minima and maxima of a function.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html">Options</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used by several functions to control their operation.  <a href="struct_t_r_t_k_1_1_optimization_1_1_options.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_result.html">Result</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure returned by several functions.  <a href="struct_t_r_t_k_1_1_optimization_1_1_result.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_optimization_1_1_gradient.html">Gradient</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a functor which is the gradient of the given function.  <a href="class_t_r_t_k_1_1_optimization_1_1_gradient.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Function , class ValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; ValueType, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a57d46d5b206adc1c3310577f1836524f">jacobian</a> (Function f, const <a class="el" href="class_t_r_t_k_1_1_coordinate.html">Coordinate</a>&lt; ValueType &gt; &amp;x, <a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html">Options</a>&lt; ValueType &gt; options=<a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html">Options</a>&lt; ValueType &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian of f at x.  <a href="#a57d46d5b206adc1c3310577f1836524f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ValueType , class Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_t_r_t_k_1_1_optimization_1_1_gradient.html">Gradient</a>&lt; Function, ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a9b63d6a96bdf9222505dd8a894ba1eef">makeGradient</a> (Function &amp;function, <a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html">Options</a>&lt; ValueType &gt; options=<a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html">Options</a>&lt; ValueType &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of <a class="el" href="class_t_r_t_k_1_1_optimization_1_1_gradient.html" title="Generates a functor which is the gradient of the given function.">Gradient</a>. The template argument types are automatically deduced.  <a href="#a9b63d6a96bdf9222505dd8a894ba1eef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Function , class ValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_result.html">Result</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a5444c0119ca86147391989b4a20ea8a6">solve</a> (Function function, const <a class="el" href="class_t_r_t_k_1_1_coordinate.html">Coordinate</a>&lt; ValueType &gt; &amp;start_value, <a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html">Options</a>&lt; ValueType &gt; options=<a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html">Options</a>&lt; ValueType &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function solves for the root (zero) of a given function.  <a href="#a5444c0119ca86147391989b4a20ea8a6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class UnaryFunction , class ValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a270580dffe03da11a7c745c9037ea8a9">solve1D</a> (UnaryFunction f, ValueType start_value, unsigned max_number_iterations=25)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function solves for the root (zero) of a given function.  <a href="#a270580dffe03da11a7c745c9037ea8a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Function , class ValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_result.html">Result</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a2740acef116b835b6c18d69acf41f4ed">solveLevenbergMarquardt</a> (Function function, const <a class="el" href="class_t_r_t_k_1_1_coordinate.html">Coordinate</a>&lt; ValueType &gt; &amp;start_value, <a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html">Options</a>&lt; ValueType &gt; options=<a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html">Options</a>&lt; ValueType &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function solves for the root (zero) of a given function.  <a href="#a2740acef116b835b6c18d69acf41f4ed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Function , class ValueType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_result.html">Result</a>&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a6d832dd2eede65349208f27bd12f1115">solveNewtonRaphsonMethod</a> (Function function, const <a class="el" href="class_t_r_t_k_1_1_coordinate.html">Coordinate</a>&lt; ValueType &gt; &amp;start_value, <a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html">Options</a>&lt; ValueType &gt; options=<a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html">Options</a>&lt; ValueType &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function solves for the root (zero) of a given function.  <a href="#a6d832dd2eede65349208f27bd12f1115"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This namespace contains various classes and functions to find the roots (zeros) or the local minima and maxima of a function. </p>
<p><b>List of classes and functions:</b></p>
<ul>
<li><a class="el" href="class_t_r_t_k_1_1_optimization_1_1_gradient.html">Gradient</a></li>
<li><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a57d46d5b206adc1c3310577f1836524f">jacobian()</a></li>
<li><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a9b63d6a96bdf9222505dd8a894ba1eef">makeGradient()</a></li>
<li><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a5444c0119ca86147391989b4a20ea8a6">solve()</a><ul>
<li><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a2740acef116b835b6c18d69acf41f4ed">solveLevenbergMarquardt()</a></li>
<li><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a6d832dd2eede65349208f27bd12f1115">solveNewtonRaphsonMethod()</a></li>
</ul>
</li>
<li><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a270580dffe03da11a7c745c9037ea8a9">solve1D()</a></li>
</ul>
<dl class="user"><dt><b>Macros:</b></dt><dd></dd></dl>
<p>If <a class="el" href="_definitions_8hpp.html#a3398b9bb45eeddf1eeb15af3497f0015">TRTK_PARALLELIZE</a> is defined some algorithms will make use of OpenMP.</p>
<p><b>Example:</b></p>
<p>The following example shows how these functions can be used to estimate an unknown transformation between two point sets:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;cassert&gt;</span>
<span class="preprocessor"> #include &lt;cmath&gt;</span>
<span class="preprocessor"> #include &lt;iomanip&gt;</span>
<span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;vector&gt;</span>

<span class="preprocessor"> #include &lt;<a class="code" href="_clock_8hpp.html" title="This file contains the declarations of the Clock class and related functions.">TRTK/Clock.hpp</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_coordinate_8hpp.html" title="This file contains the Coordinate class and related functions.">TRTK/Coordinate.hpp</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_optimization_8hpp.html" title="This file contains various functions to find the roots (zeros) or the local minima and maxima of a fu...">TRTK/Optimization.hpp</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_tools_8hpp.html" title="This file contains various helper functions.">TRTK/Tools.hpp</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_transform2_d_8hpp.html" title="This file contains the Transform2D class.">TRTK/Transform2D.hpp</a>&gt;</span>

 <span class="keyword">using namespace </span>std;
 <span class="keyword">using namespace </span>TRTK;
 <span class="keyword">using namespace </span>TRTK::Optimization;
 <span class="keyword">using namespace </span>TRTK::Tools;


 <span class="keyword">class </span>EstimateTransformation
 {
 <span class="keyword">public</span>:
     EstimateTransformation(<span class="keyword">const</span> vector&lt;Coordinate&lt;double&gt; &gt; &amp; source_points,
                            <span class="keyword">const</span> vector&lt;Coordinate&lt;double&gt; &gt; &amp; target_points);

     <span class="comment">// Returns the error of the transformation which is defined by the given coefficients.</span>
     <span class="keywordtype">double</span> operator()(<span class="keyword">const</span> Coordinate&lt;double&gt; &amp; coefficients) <span class="keyword">const</span>;

 <span class="keyword">private</span>:
     <span class="keyword">const</span> vector&lt;Coordinate&lt;double&gt; &gt; &amp; source_points;
     <span class="keyword">const</span> vector&lt;Coordinate&lt;double&gt; &gt; &amp; target_points;
 };


 EstimateTransformation::EstimateTransformation(<span class="keyword">const</span> vector&lt;Coordinate&lt;double&gt; &gt; &amp; source_points,
                                                <span class="keyword">const</span> vector&lt;Coordinate&lt;double&gt; &gt; &amp; target_points) :
     source_points(source_points),
     target_points(target_points)
 {
 }


 <span class="keywordtype">double</span> EstimateTransformation::operator()(<span class="keyword">const</span> Coordinate&lt;double&gt; &amp; coefficients)<span class="keyword"> const</span>
<span class="keyword"> </span>{
     <span class="comment">// Returns the Mean Square Error (MSE) of the currently estimated transformation.</span>

     Transform2D&lt;double&gt; transform(coefficients[0], coefficients[1], coefficients[2],
                                   coefficients[3], coefficients[4], coefficients[5],
                                   0,               0,               1);

     <span class="keywordtype">double</span> error = 0;

     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> N = source_points.size();

     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; N; ++i)
     {
         <span class="keywordtype">double</span> residual = (transform * source_points[i] - target_points[i]).norm();
         error += residual * residual;
     }

     <span class="keywordflow">return</span> error / N;
 }


 <span class="keywordtype">int</span> main()
 {
     <span class="comment">// Generate an abitrary transformation.</span>

     Transform2D&lt;double&gt; transform;

     transform.<a class="code" href="class_t_r_t_k_1_1_transform3_d.html#a799935c4555a35bbcfba5b36c67b8b86" title="Rotation around the x-, y-, or z-axis.">rotate</a>(0.927295218).shear(1, 0).<a class="code" href="class_t_r_t_k_1_1_transform3_d.html#a8e753da9fee9d7d15a0bc63c4bcc5838" title="Non-uniform scaling.">scale</a>(2, 2).<a class="code" href="class_t_r_t_k_1_1_transform3_d.html#a000850e76a1cccf906d6a4cd5464a206" title="Translation.">translate</a>(1, -2);

     <span class="comment">// Construct some source points and some target points which</span>
     <span class="comment">// are the transformed source points.</span>

     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> N = 200;

     vector&lt;Coordinate&lt;double&gt; &gt; source_points;
     vector&lt;Coordinate&lt;double&gt; &gt; target_points;

     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; N; ++i)
     {
         <span class="keywordtype">double</span> x = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a906509578c3f4dec953fa41ed8e06ec9" title="Random sample of the standard uniform distribution.">rand</a>(-100.0, 100.0);
         <span class="keywordtype">double</span> y = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a906509578c3f4dec953fa41ed8e06ec9" title="Random sample of the standard uniform distribution.">rand</a>(-100.0, 100.0);

         Coordinate&lt;double&gt; source_point(x, y);
         Coordinate&lt;double&gt; target_point = transform * source_point;

         source_points.push_back(source_point);
         target_points.push_back(target_point);
     }

     <span class="comment">// Estimate the transformation.</span>

     Clock clock;

     EstimateTransformation estimateTransformation(source_points, target_points);

     Coordinate&lt;double&gt; coefficients; <span class="comment">// = {a11, a12, a13, a21, a22, a23} in Transform2D</span>
     coefficients.resize(6, 1);

     Options&lt;double&gt; options;
     options.error_tolerance = 1e-10;

     Result&lt;double&gt; result = <a class="code" href="namespace_t_r_t_k_1_1_optimization.html#a5444c0119ca86147391989b4a20ea8a6" title="This function solves for the root (zero) of a given function.">solve</a>(makeGradient&lt;double&gt;(estimateTransformation),
                                   coefficients,
                                   options);

     <span class="comment">// Print the result.</span>

     cout &lt;&lt; <span class="stringliteral">&quot;Original transformation matrix:&quot;</span> &lt;&lt; endl &lt;&lt; endl;

     cout &lt;&lt; setw(6) &lt;&lt; transform.a11() &lt;&lt; setw(6) &lt;&lt; transform.a12() &lt;&lt; setw(6) &lt;&lt; transform.a13() &lt;&lt; endl
          &lt;&lt; setw(6) &lt;&lt; transform.a21() &lt;&lt; setw(6) &lt;&lt; transform.a22() &lt;&lt; setw(6) &lt;&lt; transform.a23() &lt;&lt; endl
          &lt;&lt; setw(6) &lt;&lt; transform.a31() &lt;&lt; setw(6) &lt;&lt; transform.a32() &lt;&lt; setw(6) &lt;&lt; transform.a33() &lt;&lt; endl
          &lt;&lt; endl;

     ios_base::fmtflags flags = cout.flags();

     cout &lt;&lt; <span class="stringliteral">&quot;Result:    &quot;</span> &lt;&lt; endl &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Error      &quot;</span> &lt;&lt; result.error &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Iterations &quot;</span> &lt;&lt; result.number_of_iterations &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Root       &quot;</span> &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; result.root &lt;&lt; endl &lt;&lt; endl;

     cout.flags(flags);

     cout &lt;&lt; clock &lt;&lt; endl;

     <span class="keywordflow">return</span> 0;
 }
</pre></div><p>The output is:</p>
<div class="fragment"><pre class="fragment"> Original transformation matrix:

    2.8  -0.4     1
    1.6   1.2    -2
      0     0     1

 Result:

 <a class="code" href="namespace_t_r_t_k_1_1_diffusion.html#a638f7cf0e236aab0d2b425895589e488" title="Error Codes.">Error</a>      8.0176e-14
 Iterations 3
 Root       (2.800, -0.400, 1.000, 1.600, 1.200, -2.000)

 Elapsed time: 0.11 seconds.
</pre></div> <hr/><h2>Function Documentation</h2>
<a class="anchor" id="a57d46d5b206adc1c3310577f1836524f"></a><!-- doxytag: member="TRTK::Optimization::jacobian" ref="a57d46d5b206adc1c3310577f1836524f" args="(Function f, const Coordinate&lt; ValueType &gt; &amp;x, Options&lt; ValueType &gt; options=Options&lt; ValueType &gt;())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function , class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;ValueType, Eigen::Dynamic, Eigen::Dynamic&gt; TRTK::Optimization::jacobian </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options&lt; ValueType &gt;&#160;</td>
          <td class="paramname"> <em>options</em> = <code>Options&lt;ValueType&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the Jacobian of f at x. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Vector-valued multivariate function or functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector-valued input argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html" title="Structure used by several functions to control their operation.">Options</a> to control the operation of this function.</td></tr>
  </table>
  </dd>
</dl>
<p>The Jacobian of <code>function</code> is computed numerically using a higher order method, namely the five-point stencil method. The spacing used when computing the finit difference can be set in <code>options</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The type of the input argument as well as the type of the return value of the given function must be <a class="el" href="class_t_r_t_k_1_1_coordinate.html" title="A generic coordinate class.">Coordinate</a>.</dd></dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;cassert&gt;</span>
<span class="preprocessor"> #include &lt;cmath&gt;</span>
<span class="preprocessor"> #include &lt;iostream&gt;</span>

<span class="preprocessor"> #include &lt;<a class="code" href="_coordinate_8hpp.html" title="This file contains the Coordinate class and related functions.">TRTK/Coordinate.hpp</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_optimization_8hpp.html" title="This file contains various functions to find the roots (zeros) or the local minima and maxima of a fu...">TRTK/Optimization.hpp</a>&gt;</span>

 <span class="keyword">using namespace </span>std;
 <span class="keyword">using namespace </span>TRTK;
 <span class="keyword">using namespace </span>TRTK::Optimization;

 Coordinate&lt;double&gt; f(<span class="keyword">const</span> Coordinate&lt;double&gt; &amp; arg)
 {
     assert(arg.size() == 2);

     <span class="keyword">const</span> <span class="keywordtype">double</span> x = arg.x();
     <span class="keyword">const</span> <span class="keywordtype">double</span> y = arg.y();

     Coordinate&lt;double&gt; result(0, 0);

     result.x() = (x - 2) * (y - 1);
     result.y() = -3 * y;

     <span class="keywordflow">return</span> result;
 }

 <span class="keywordtype">int</span> main()
 {
     Coordinate&lt;double&gt; arg(5, 5);
     cout &lt;&lt; <a class="code" href="namespace_t_r_t_k_1_1_optimization.html#a57d46d5b206adc1c3310577f1836524f" title="Computes the Jacobian of f at x.">jacobian</a>(f, arg);
     <span class="keywordflow">return</span> 0;
 }
</pre></div><p>Output:</p>
<div class="fragment"><pre class="fragment"> 4  3
 0 -3
</pre></div><dl class="user"><dt><b>Macros:</b></dt><dd>If <code style="color:blue">TRTK_PARALLELIZE_JACOBIAN</code> is defined <code>jacobian</code> will make use of OpenMP. Be aware that <code>f</code> needs to be reentrant (i.e. it can be safely executed concurrently).</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Christoph Haenisch </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.1.1 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>last changed on 2013-08-15 </dd></dl>

<p>Definition at line <a class="el" href="_optimization_8hpp_source.html#l00503">503</a> of file <a class="el" href="_optimization_8hpp_source.html">Optimization.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b63d6a96bdf9222505dd8a894ba1eef"></a><!-- doxytag: member="TRTK::Optimization::makeGradient" ref="a9b63d6a96bdf9222505dd8a894ba1eef" args="(Function &amp;function, Options&lt; ValueType &gt; options=Options&lt; ValueType &gt;())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType , class Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_r_t_k_1_1_optimization_1_1_gradient.html">Gradient</a>&lt;Function, ValueType&gt; TRTK::Optimization::makeGradient </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options&lt; ValueType &gt;&#160;</td>
          <td class="paramname"> <em>options</em> = <code>Options&lt;ValueType&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an instance of <a class="el" href="class_t_r_t_k_1_1_optimization_1_1_gradient.html" title="Generates a functor which is the gradient of the given function.">Gradient</a>. The template argument types are automatically deduced. </p>
<p>Please, have a look at <a class="el" href="class_t_r_t_k_1_1_optimization_1_1_gradient.html">Gradient</a> for more details.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;cassert&gt;</span>
<span class="preprocessor"> #include &lt;cmath&gt;</span>
<span class="preprocessor"> #include &lt;iostream&gt;</span>

<span class="preprocessor"> #include &lt;<a class="code" href="_coordinate_8hpp.html" title="This file contains the Coordinate class and related functions.">TRTK/Coordinate.hpp</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_optimization_8hpp.html" title="This file contains various functions to find the roots (zeros) or the local minima and maxima of a fu...">TRTK/Optimization.hpp</a>&gt;</span>

 <span class="keyword">using namespace </span>std;
 <span class="keyword">using namespace </span>TRTK;
 <span class="keyword">using namespace </span>TRTK::Optimization;

 <span class="keywordtype">double</span> f(<span class="keyword">const</span> <a class="code" href="class_t_r_t_k_1_1_coordinate.html" title="A generic coordinate class.">TRTK::Coordinate&lt;double&gt;</a> &amp; arg)
 {
     assert(arg.<a class="code" href="class_t_r_t_k_1_1_coordinate.html#af41309082a015b059fe4f50e2d8b37b5">size</a>() == 2);

     <span class="keyword">const</span> <span class="keywordtype">double</span> x = arg.<a class="code" href="class_t_r_t_k_1_1_coordinate.html#a48590fa280f1551aa1c1fb999118572a" title="Returns the first component.">x</a>();
     <span class="keyword">const</span> <span class="keywordtype">double</span> y = arg.<a class="code" href="class_t_r_t_k_1_1_coordinate.html#a86aac85b568e964950c9faf5956a369c" title="Returns the second component.">y</a>();

     <span class="keywordflow">return</span> (x - 2) * (x - 2)  - (y - 1) * (y - 1) - 9;
 }

 <span class="keywordtype">int</span> main()
 {
     <span class="comment">// Find the minimum of f (i.e. the zero of grad f).</span>

     Coordinate&lt;double&gt; arg(100, -2); <span class="comment">// initial guess</span>

     Result&lt;double&gt; result = <a class="code" href="namespace_t_r_t_k_1_1_optimization.html#a6d832dd2eede65349208f27bd12f1115" title="This function solves for the root (zero) of a given function.">solveNewtonRaphsonMethod</a>(makeGradient&lt;double&gt;(f), arg);

     cout &lt;&lt; <span class="stringliteral">&quot;Result:    &quot;</span> &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Error      &quot;</span> &lt;&lt; result.error &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Iterations &quot;</span> &lt;&lt; result.number_of_iterations &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Root       &quot;</span> &lt;&lt; result.root &lt;&lt; endl;

     <span class="keywordflow">return</span> 0;
 }
</pre></div><p>Output:</p>
<div class="fragment"><pre class="fragment"> Result:
 <a class="code" href="namespace_t_r_t_k_1_1_diffusion.html#a638f7cf0e236aab0d2b425895589e488" title="Error Codes.">Error</a>      0
 Iterations 3
 Root       (2, 1)
</pre></div><p>Example:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>A
 {
 <span class="keyword">public</span>:
     <span class="keywordtype">double</span> f(<span class="keyword">const</span> Coordinate&lt;double&gt; &amp; arg)<span class="keyword"> const</span>
<span class="keyword">     </span>{
         <span class="comment">// ...</span>
     }

     <span class="keywordtype">double</span> operator()(<span class="keyword">const</span> Coordinate&lt;double&gt; &amp; arg)<span class="keyword"> const</span>
<span class="keyword">     </span>{
         <span class="keywordflow">return</span> f(arg);
     }
 };

 <span class="keywordtype">int</span> main()
 {
     <span class="comment">// ...</span>
     Result&lt;double&gt; result = <a class="code" href="namespace_t_r_t_k_1_1_optimization.html#a6d832dd2eede65349208f27bd12f1115" title="This function solves for the root (zero) of a given function.">solveNewtonRaphsonMethod</a>(makeGradient&lt;double&gt;(a), Coordinate&lt;double&gt; arg(0, 0));
     <span class="comment">// ...</span>
 }
</pre></div><dl class="author"><dt><b>Author:</b></dt><dd>Christoph Haenisch </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.1.1 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>last changed on 2012-11-07 </dd></dl>

<p>Definition at line <a class="el" href="_optimization_8hpp_source.html#l00632">632</a> of file <a class="el" href="_optimization_8hpp_source.html">Optimization.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5444c0119ca86147391989b4a20ea8a6"></a><!-- doxytag: member="TRTK::Optimization::solve" ref="a5444c0119ca86147391989b4a20ea8a6" args="(Function function, const Coordinate&lt; ValueType &gt; &amp;start_value, Options&lt; ValueType &gt; options=Options&lt; ValueType &gt;())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function , class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_result.html">Result</a>&lt;ValueType&gt; TRTK::Optimization::solve </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"> <em>start_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options&lt; ValueType &gt;&#160;</td>
          <td class="paramname"> <em>options</em> = <code>Options&lt;ValueType&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function solves for the root (zero) of a given function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Vector-valued multivariate function or functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_value</td><td>Value in the neighborhood of a root. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html" title="Structure used by several functions to control their operation.">Options</a> to control the operation of this function.</td></tr>
  </table>
  </dd>
</dl>
<p>This functions serves as a uniform interface for all solver functions.</p>
<p>By default the solver uses the Levenberg-Marquardt algorithm. This can be changed with the <code>options</code> parameter. Also, all parameters relevant for a particular algorithm can be set with an option object.</p>
<p>For further details please have a look at the respective function documentation.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;cassert&gt;</span>
<span class="preprocessor"> #include &lt;iostream&gt;</span>

<span class="preprocessor"> #include &lt;<a class="code" href="_coordinate_8hpp.html" title="This file contains the Coordinate class and related functions.">TRTK/Coordinate.hpp</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_optimization_8hpp.html" title="This file contains various functions to find the roots (zeros) or the local minima and maxima of a fu...">TRTK/Optimization.hpp</a>&gt;</span>

 <span class="keyword">using namespace </span>std;
 <span class="keyword">using namespace </span>TRTK;
 <span class="keyword">using namespace </span>TRTK::Optimization;

 Coordinate&lt;double&gt; f(<span class="keyword">const</span> Coordinate&lt;double&gt; &amp; arg)
 {
     assert(arg.size() == 2);

     <span class="keyword">const</span> <span class="keywordtype">double</span> x = arg.x();
     <span class="keyword">const</span> <span class="keywordtype">double</span> y = arg.y();

     Coordinate&lt;double&gt; result(0, 0);

     result.x() = (x - 2) * (y - 1);
     result.y() = -3 * y;

     <span class="keywordflow">return</span> result;
 }

 <span class="keywordtype">int</span> main()
 {
     Coordinate&lt;double&gt; arg(100, -2);

     Result&lt;double&gt; result = <a class="code" href="namespace_t_r_t_k_1_1_optimization.html#a5444c0119ca86147391989b4a20ea8a6" title="This function solves for the root (zero) of a given function.">solve</a>(f, arg);

     cout &lt;&lt; <span class="stringliteral">&quot;Result:    &quot;</span> &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Iterations &quot;</span> &lt;&lt; result.number_of_iterations &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Error      &quot;</span> &lt;&lt; result.error &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Root       &quot;</span> &lt;&lt; result.root &lt;&lt; endl;

     <span class="keywordflow">return</span> 0;
 }
</pre></div><p>Output:</p>
<div class="fragment"><pre class="fragment"> Result: 
 Iterations 5
 <a class="code" href="namespace_t_r_t_k_1_1_diffusion.html#a638f7cf0e236aab0d2b425895589e488" title="Error Codes.">Error</a>      2.2523e-023
 Root       (2, 1.06174e-023)
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a2740acef116b835b6c18d69acf41f4ed" title="This function solves for the root (zero) of a given function.">solveLevenbergMarquardt()</a>, <a class="el" href="namespace_t_r_t_k_1_1_optimization.html#a6d832dd2eede65349208f27bd12f1115" title="This function solves for the root (zero) of a given function.">solveNewtonRaphsonMethod()</a></dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Christoph Haenisch </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.1.0 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>last changed on 2012-11-09 </dd></dl>

<p>Definition at line <a class="el" href="_optimization_8hpp_source.html#l00712">712</a> of file <a class="el" href="_optimization_8hpp_source.html">Optimization.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a270580dffe03da11a7c745c9037ea8a9"></a><!-- doxytag: member="TRTK::Optimization::solve1D" ref="a270580dffe03da11a7c745c9037ea8a9" args="(UnaryFunction f, ValueType start_value, unsigned max_number_iterations=25)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UnaryFunction , class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType TRTK::Optimization::solve1D </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"> <em>start_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"> <em>max_number_iterations</em> = <code>25</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function solves for the root (zero) of a given function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Unary function or functor (e.g. <code>double f(double)</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_value</td><td>Value in the neighborhood of a root. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_number_iterations</td><td>Maximum number of iterations to perform.</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements the Newton-Raphson method. In order to converge, the initial estimate (<code>start_value</code>) must be sufficient close to the root. At most <code>max_number_iterations</code> iterations are performed. The derivative of <code>f</code> is computed numerically using a higher order method (five-point stencil).</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="_coordinate_8hpp.html" title="This file contains the Coordinate class and related functions.">TRTK/Coordinate.hpp</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_optimization_8hpp.html" title="This file contains various functions to find the roots (zeros) or the local minima and maxima of a fu...">TRTK/Optimization.hpp</a>&gt;</span>

 <span class="keyword">using namespace </span>TRTK;
 <span class="keyword">using namespace </span>TRTK::Optimization;

 <span class="keywordtype">double</span> f(<span class="keywordtype">double</span> x)
 {
     <span class="keywordflow">return</span> x * x - 2;
 }

 <span class="keywordtype">int</span> main()
 {
     <a class="code" href="namespace_t_r_t_k_1_1_optimization.html#a270580dffe03da11a7c745c9037ea8a9" title="This function solves for the root (zero) of a given function.">solve1D</a>(f, 1.0); <span class="comment">// returns sqrt(2)</span>
     <span class="keywordflow">return</span> 0;
 }
</pre></div><dl class="author"><dt><b>Author:</b></dt><dd>Christoph Haenisch </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.1.0 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>last changed on 2012-11-07 </dd></dl>

<p>Definition at line <a class="el" href="_optimization_8hpp_source.html#l00767">767</a> of file <a class="el" href="_optimization_8hpp_source.html">Optimization.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2740acef116b835b6c18d69acf41f4ed"></a><!-- doxytag: member="TRTK::Optimization::solveLevenbergMarquardt" ref="a2740acef116b835b6c18d69acf41f4ed" args="(Function function, const Coordinate&lt; ValueType &gt; &amp;start_value, Options&lt; ValueType &gt; options=Options&lt; ValueType &gt;())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function , class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_result.html">Result</a>&lt;ValueType&gt; TRTK::Optimization::solveLevenbergMarquardt </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"> <em>start_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options&lt; ValueType &gt;&#160;</td>
          <td class="paramname"> <em>options</em> = <code>Options&lt;ValueType&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function solves for the root (zero) of a given function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Vector-valued multivariate function or functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_value</td><td>Value in the neighborhood of a root. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html" title="Structure used by several functions to control their operation.">Options</a> to control the operation of this function.</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements the Levenberg-Marquardt algorithm [1] which aims to minimize the error criterion </p>
<p class="formulaDsp">
\[ \Phi = \| f(x) \|^2 = \sum_{i=0}^{n} f_i(x)^2 \]
</p>
<p> by iteratively solving the equation </p>
<p class="formulaDsp">
\[ (JJ^T + \lambda \text{diag}(JJ^T)) \Delta x = -J^T f(x) \]
</p>
<p> where \( f(x + \Delta x) \approx f(x) + J \Delta x \).</p>
<p>The Levenberg-Marquardt algorithm can be interpreted as interpolating between the <a class="el" href="class_t_r_t_k_1_1_optimization_1_1_gradient.html" title="Generates a functor which is the gradient of the given function.">Gradient</a> Descent and the Newton-Raphson method depending on the damping parameter \( \lambda \). A high value of \( \lambda \) leads to a more <a class="el" href="class_t_r_t_k_1_1_optimization_1_1_gradient.html" title="Generates a functor which is the gradient of the given function.">Gradient</a> Descent like characteristic which is advantageous in the case of a suboptimal start value. The parameter is adjusted at each iteration. The damping can be controlled with the paramters <code>options.lambda</code> and <code>options.nu</code>.</p>
<p>In order to converge, the initial estimate (<code>start_value</code>) must be sufficient close to the root. The algorithm is terminated if the residual is smaller than the given error tolerance or if the maximum number of iterations is reached.</p>
<p>The Jacobian of <code>function</code> is computed numerically using a higher order method (i.e. five-point stencil method). The spacing used when computing the finit difference can be set in <code>options</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The type of the input argument as well as the type of the return value of the given function must be <a class="el" href="class_t_r_t_k_1_1_coordinate.html" title="A generic coordinate class.">Coordinate</a>.</dd></dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;cassert&gt;</span>
<span class="preprocessor"> #include &lt;iostream&gt;</span>

<span class="preprocessor"> #include &lt;<a class="code" href="_coordinate_8hpp.html" title="This file contains the Coordinate class and related functions.">TRTK/Coordinate.hpp</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_optimization_8hpp.html" title="This file contains various functions to find the roots (zeros) or the local minima and maxima of a fu...">TRTK/Optimization.hpp</a>&gt;</span>

 <span class="keyword">using namespace </span>std;
 <span class="keyword">using namespace </span>TRTK;
 <span class="keyword">using namespace </span>TRTK::Optimization;

 Coordinate&lt;double&gt; f(<span class="keyword">const</span> Coordinate&lt;double&gt; &amp; arg)
 {
     assert(arg.size() == 2);

     <span class="keyword">const</span> <span class="keywordtype">double</span> x = arg.x();
     <span class="keyword">const</span> <span class="keywordtype">double</span> y = arg.y();

     Coordinate&lt;double&gt; result(0, 0);

     result.x() = (x - 2) * (y - 1);
     result.y() = -3 * y;

     <span class="keywordflow">return</span> result;
 }

 <span class="keywordtype">int</span> main()
 {
     Coordinate&lt;double&gt; arg(100, -2);

     Result&lt;double&gt; result = <a class="code" href="namespace_t_r_t_k_1_1_optimization.html#a2740acef116b835b6c18d69acf41f4ed" title="This function solves for the root (zero) of a given function.">solveLevenbergMarquardt</a>(f, arg);

     cout &lt;&lt; <span class="stringliteral">&quot;Result:    &quot;</span> &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Iterations &quot;</span> &lt;&lt; result.number_of_iterations &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Error      &quot;</span> &lt;&lt; result.error &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Root       &quot;</span> &lt;&lt; result.root &lt;&lt; endl;

     <span class="keywordflow">return</span> 0;
 }
</pre></div><p>Output:</p>
<div class="fragment"><pre class="fragment"> Result: 
 Iterations 5
 <a class="code" href="namespace_t_r_t_k_1_1_diffusion.html#a638f7cf0e236aab0d2b425895589e488" title="Error Codes.">Error</a>      2.2523e-023
 Root       (2, 1.06174e-023)
</pre></div><dl class="user"><dt><b>References:</b></dt><dd></dd></dl>
<p>[1] Donald W. Marquardt, "An Algorithm for Least Squares Estimation
     of Nonlinear Parameters", Journal of the Society dor Industrial and Applied Mathematics, Vol. 11, No. 2, 1963</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Christoph Haenisch </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.1.0 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>last changed on 2012-11-07 </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>There is a known bug in the implementation. Do not use this algorithm until the bug is fixed. </dd></dl>

<p>Definition at line <a class="el" href="_optimization_8hpp_source.html#l00894">894</a> of file <a class="el" href="_optimization_8hpp_source.html">Optimization.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d832dd2eede65349208f27bd12f1115"></a><!-- doxytag: member="TRTK::Optimization::solveNewtonRaphsonMethod" ref="a6d832dd2eede65349208f27bd12f1115" args="(Function function, const Coordinate&lt; ValueType &gt; &amp;start_value, Options&lt; ValueType &gt; options=Options&lt; ValueType &gt;())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function , class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_result.html">Result</a>&lt;ValueType&gt; TRTK::Optimization::solveNewtonRaphsonMethod </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coordinate&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"> <em>start_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Options&lt; ValueType &gt;&#160;</td>
          <td class="paramname"> <em>options</em> = <code>Options&lt;ValueType&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function solves for the root (zero) of a given function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Vector-valued multivariate function or functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_value</td><td>Value in the neighborhood of a root. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td><a class="el" href="struct_t_r_t_k_1_1_optimization_1_1_options.html" title="Structure used by several functions to control their operation.">Options</a> to control the operation of this function.</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements the Newton-Raphson method. In order to converge, the initial estimate (<code>start_value</code>) must be sufficient close to the root. The algorithm is terminated if the residual is smaller than the given error tolerance or if the maximum number of iterations is reached.</p>
<p>The Jacobian of <code>function</code> is computed numerically using a higher order method (i.e. five-point stencil method). The spacing used when computing the finit difference can be set in <code>options</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The type of the input argument as well as the type of the return value of the given function must be <a class="el" href="class_t_r_t_k_1_1_coordinate.html" title="A generic coordinate class.">Coordinate</a>.</dd></dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;cassert&gt;</span>
<span class="preprocessor"> #include &lt;iostream&gt;</span>

<span class="preprocessor"> #include &lt;<a class="code" href="_coordinate_8hpp.html" title="This file contains the Coordinate class and related functions.">TRTK/Coordinate.hpp</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_optimization_8hpp.html" title="This file contains various functions to find the roots (zeros) or the local minima and maxima of a fu...">TRTK/Optimization.hpp</a>&gt;</span>

 <span class="keyword">using namespace </span>std;
 <span class="keyword">using namespace </span>TRTK;
 <span class="keyword">using namespace </span>TRTK::Optimization;

 Coordinate&lt;double&gt; f(<span class="keyword">const</span> Coordinate&lt;double&gt; &amp; arg)
 {
     assert(arg.size() == 2);

     <span class="keyword">const</span> <span class="keywordtype">double</span> x = arg.x();
     <span class="keyword">const</span> <span class="keywordtype">double</span> y = arg.y();

     Coordinate&lt;double&gt; result(0, 0);

     result.x() = (x - 2) * (y - 1);
     result.y() = -3 * y;

     <span class="keywordflow">return</span> result;
 }

 <span class="keywordtype">int</span> main()
 {
     Coordinate&lt;double&gt; arg(100, -2);

     Result&lt;double&gt; result = <a class="code" href="namespace_t_r_t_k_1_1_optimization.html#a6d832dd2eede65349208f27bd12f1115" title="This function solves for the root (zero) of a given function.">solveNewtonRaphsonMethod</a>(f, arg);

     cout &lt;&lt; <span class="stringliteral">&quot;Result:    &quot;</span> &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Iterations &quot;</span> &lt;&lt; result.number_of_iterations &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Error      &quot;</span> &lt;&lt; result.error &lt;&lt; endl
          &lt;&lt; <span class="stringliteral">&quot;Root       &quot;</span> &lt;&lt; result.root &lt;&lt; endl;

     <span class="keywordflow">return</span> 0;
 }
</pre></div><p>Output:</p>
<div class="fragment"><pre class="fragment"> Result:
 Iterations 3
 <a class="code" href="namespace_t_r_t_k_1_1_diffusion.html#a638f7cf0e236aab0d2b425895589e488" title="Error Codes.">Error</a>      1.04589e-31
 Root       (2, -4.93038e-32)
</pre></div><dl class="author"><dt><b>Author:</b></dt><dd>Christoph Haenisch </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.1.0 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>last changed on 2012-06-10 </dd></dl>

<p>Definition at line <a class="el" href="_optimization_8hpp_source.html#l01118">1118</a> of file <a class="el" href="_optimization_8hpp_source.html">Optimization.hpp</a>.</p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/>
    <address class="footer">
        <small>
            Copyright 2010 - 2014 by Christoph Hänisch,
            Chair of Medical Engineering (mediTEC),
            RWTH Aachen University <p>
            Documentation generated by <a href="http://www.doxygen.org/index.html"> Doxygen </a>
        </small>
    </address>

</body>
</html>
