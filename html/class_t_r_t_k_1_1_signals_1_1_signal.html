<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Transformation and Registration Toolkit: TRTK::Signals::Signal&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<script src="../mathjax/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespace_t_r_t_k.html">TRTK</a>      </li>
      <li><a class="el" href="namespace_t_r_t_k_1_1_signals.html">Signals</a>      </li>
      <li><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">Signal</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<h1>TRTK::Signals::Signal&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="TRTK::Signals::Signal" --><!-- doxytag: inherits="TRTK::Signals::SignalBase" -->
<p>Basic signals and slots support.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>&gt;</code></p>

<p>Inherits TRTK::Signals::SignalBase.</p>

<p><a href="class_t_r_t_k_1_1_signals_1_1_signal-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a80ed90f656ed40c371c311c813318269">connect</a> (slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a non-static non-constant member function with four parameters.  <a href="#a80ed90f656ed40c371c311c813318269"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a5d7fa4745926651026eea52c9a5710e6">connect</a> (slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a non-static non-constant member function with three parameters.  <a href="#a5d7fa4745926651026eea52c9a5710e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a3bdc365987a7c35a5fbe796d5dfedb22">connect</a> (slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a non-static non-constant member function with two parameters.  <a href="#a3bdc365987a7c35a5fbe796d5dfedb22"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a15044a7d84ee7f6d9098148b3200678c">connect</a> (slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a non-static non-constant member function with one parameter.  <a href="#a15044a7d84ee7f6d9098148b3200678c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a898e99b9ad311c1f7db916256844ece6">connect</a> (slot_class_type *object, slot_return_type(slot_class_type::*function)(), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a non-static non-constant member function with zero parameters.  <a href="#a898e99b9ad311c1f7db916256844ece6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#abfc4420a6542874ff352167824bf52f7">connect</a> (const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type) const, <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a non-static constant member function with four parameters.  <a href="#abfc4420a6542874ff352167824bf52f7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a264c818117456d0267e815f10e26443e">connect</a> (const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type) const, <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a non-static constant member function with three parameters.  <a href="#a264c818117456d0267e815f10e26443e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#ac7f08490b0bf03f82a14798571771a2a">connect</a> (const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type) const, <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a non-static constant member function with two parameters.  <a href="#ac7f08490b0bf03f82a14798571771a2a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a728b8f316409e4878684965c7628d601">connect</a> (const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type) const, <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a non-static constant member function with one parameter.  <a href="#a728b8f316409e4878684965c7628d601"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a070cf978a4f5d224e2c33aab9f1f409d">connect</a> (const slot_class_type *object, slot_return_type(slot_class_type::*function)() const, <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to a non-static constant member function with zero parameters.  <a href="#a070cf978a4f5d224e2c33aab9f1f409d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a3bdbde4689e89b3b78854d2e75cc2a08">connect</a> (slot_return_type(*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects a global or a static member function with four parameters.  <a href="#a3bdbde4689e89b3b78854d2e75cc2a08"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#ac9541405c1140a80a0a2c3c82684ac0b">connect</a> (slot_return_type(*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects a global or a static member function with three parameters.  <a href="#ac9541405c1140a80a0a2c3c82684ac0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#ace466a83528cd0cecf06426eba0cd227">connect</a> (slot_return_type(*function)(slot_arg1_type, slot_arg2_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects a global or a static member function with two parameters.  <a href="#ace466a83528cd0cecf06426eba0cd227"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_return_type , typename slot_arg1_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aced9b51381f86f2896fbe6bd1eafa98a">connect</a> (slot_return_type(*function)(slot_arg1_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects a global or a static member function with one parameter.  <a href="#aced9b51381f86f2896fbe6bd1eafa98a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_return_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a2c12995c4214be55e5da37af0585ebc5">connect</a> (slot_return_type(*function)(), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects a global or a static member function with zero parameters.  <a href="#a2c12995c4214be55e5da37af0585ebc5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a34998902d0b899d62fb1305fe8a499a7">disconnect</a> (slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a non-static non-constant member function with four parameters.  <a href="#a34998902d0b899d62fb1305fe8a499a7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#ad8e133dcbf0975b5a2a80b69f484b05b">disconnect</a> (slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a non-static non-constant member function with three parameters.  <a href="#ad8e133dcbf0975b5a2a80b69f484b05b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a08d9f209b0bc68fea80b1d3b5cdeb08f">disconnect</a> (slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a non-static non-constant member function with two parameters.  <a href="#a08d9f209b0bc68fea80b1d3b5cdeb08f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#ad61a20f22681eff593377170a6e49826">disconnect</a> (slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a non-static non-constant member function with one parameter.  <a href="#ad61a20f22681eff593377170a6e49826"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a74e71736c2dcb7640a0f4d0e738b1ff0">disconnect</a> (slot_class_type *object, slot_return_type(slot_class_type::*function)(), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a non-static non-constant member function with zero parameters.  <a href="#a74e71736c2dcb7640a0f4d0e738b1ff0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a872fdc56c547cb924ae06054ef036e4e">disconnect</a> (const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type) const, <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a non-static constant member function with four parameters.  <a href="#a872fdc56c547cb924ae06054ef036e4e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#ac39446c30733a2f97101458e13cb9a59">disconnect</a> (const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type) const, <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a non-static constant member function with three parameters.  <a href="#ac39446c30733a2f97101458e13cb9a59"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a8ad584ed7766aef0168e5136706564a2">disconnect</a> (const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type) const, <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a non-static constant member function with two parameters.  <a href="#a8ad584ed7766aef0168e5136706564a2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a4a35097a44ca3747c6deed3b6065961b">disconnect</a> (const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type) const, <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a non-static constant member function with one parameter.  <a href="#a4a35097a44ca3747c6deed3b6065961b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_class_type , typename slot_return_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#abc5d93cded64e95f3003613cc2c0719d">disconnect</a> (const slot_class_type *object, slot_return_type(slot_class_type::*function)() const, <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a non-static constant member function with zero parameters.  <a href="#abc5d93cded64e95f3003613cc2c0719d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aad48d4b4972689d9a7a551bb4e925ae0">disconnect</a> (slot_return_type(*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a global or a static member function with four parameters.  <a href="#aad48d4b4972689d9a7a551bb4e925ae0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a7360559edec91f5a606251ce733d6d25">disconnect</a> (slot_return_type(*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a global or a static member function with three parameters.  <a href="#a7360559edec91f5a606251ce733d6d25"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a61f82506ad07b320c5c42cdf3a179383">disconnect</a> (slot_return_type(*function)(slot_arg1_type, slot_arg2_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a global or a static member function with two parameters.  <a href="#a61f82506ad07b320c5c42cdf3a179383"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_return_type , typename slot_arg1_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#abb80491a6fa72e9c977476e3f7f741b2">disconnect</a> (slot_return_type(*function)(slot_arg1_type), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a global or a static member function with one parameter.  <a href="#abb80491a6fa72e9c977476e3f7f741b2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename slot_return_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a5f658294c45cbde1d6dd8d71342fe190">disconnect</a> (slot_return_type(*function)(), <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a global or a static member function with zero parameters.  <a href="#a5f658294c45cbde1d6dd8d71342fe190"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#a24a381ac7ee44834b7ec099615a1154c">send</a> (arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a signal.  <a href="#a24a381ac7ee44834b7ec099615a1154c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13b3e0e856c5dcf5b19cac2875fd12aa"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="a13b3e0e856c5dcf5b19cac2875fd12aa" args="(SlotAdapterBase *slot, const ConnectionType connection_type=SINGLE_CONNECTION) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>connect</b> (SlotAdapterBase *slot, const <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2ea1149ae5657274daf2cecdc80de77"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="ab2ea1149ae5657274daf2cecdc80de77" args="(SlotAdapterBase *slot, const ConnectionType connection_type=SINGLE_CONNECTION) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>disconnect</b> (SlotAdapterBase *slot, const <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> connection_type=SINGLE_CONNECTION) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a223a655cb8b40a1ca7fca644a56a9aa4"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnectReceiver" ref="a223a655cb8b40a1ca7fca644a56a9aa4" args="(const SlotAdapterBase *slot) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>disconnectReceiver</b> (const SlotAdapterBase *slot) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71a8104545ed2a93871269221fb4d61c"></a><!-- doxytag: member="TRTK::Signals::Signal::isConnected" ref="a71a8104545ed2a93871269221fb4d61c" args="(const SlotAdapterBase *slot) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isConnected</b> (const SlotAdapterBase *slot) const </td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfa0474ea409374c6f01cd0488dad243"></a><!-- doxytag: member="TRTK::Signals::Signal::m_slots" ref="abfa0474ea409374c6f01cd0488dad243" args="" -->
std::list&lt; SlotAdapterBase * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_slots</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3094954c9a317be9c27c5a8342a9aeb"></a><!-- doxytag: member="TRTK::Signals::Signal::m_receivers" ref="ab3094954c9a317be9c27c5a8342a9aeb" args="" -->
std::set&lt; const Receiver * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_receivers</b></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2"><p>(Note that these are not member functions.) </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a> { <a class="el" href="namespace_t_r_t_k_1_1_signals.html#aa1f0e2efd52935fd01bfece0fbead81fadcd3d551d68cc4d609d986ddfe322cc7">MULTIPLE_CONNECTIONS</a>, 
<a class="el" href="namespace_t_r_t_k_1_1_signals.html#aa1f0e2efd52935fd01bfece0fbead81fa625aad836ed3b60cb0c295332d6554bc">SINGLE_CONNECTION</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Slot connection type. </p>
 <a href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">More...</a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename arg1_type = void, typename arg2_type = void, typename arg3_type = void, typename arg4_type = void&gt;<br/>
 class TRTK::Signals::Signal&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;</h3>

<p>Basic signals and slots support. </p>
<p><a class="el" href="namespace_t_r_t_k_1_1_signals.html" title="This namespace contains various classes and functions related to the signals and slots implementation...">Signals</a> and slots are callbacks with multiple targets. They work according to the publish/subscribe pattern which facilitates decoupling and modularization. A signal with certain properties is defined and subscribers with the same method signature are able to connect to this signal (or in other words: if a signal is instanciated, only a defined set of functions is able to be connected to the signal). If the signal is called (or emitted or send), the subscribers are informed (or called) as well. A publisher does not care about its subscribers---it just publishes and the subscribers are informed. All this is done fully transparently. (See below for some examples.)</p>
<p>This signals and slots implementation is compatible with Qt, which means that it does not interfere with Qt's own signals and slots concept as well as its defined keywords <em>emit</em>, <em>signals</em> and <em>slots</em>.</p>
<p>The interface is designed to be flexible and easy to use. Connections are even managed fully automatically in the case that objects are (virtually) derived from the Receiver class.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>Object : <span class="keyword">virtual</span> <span class="keyword">public</span> Receiver
 {
     <span class="comment">// ...</span>
 };
</pre></div><p>A signal is defined by instanciating the <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html" title="Basic signals and slots support.">Signal</a> template class. For instance:</p>
<div class="fragment"><pre class="fragment"> Signal&lt;int&gt; signal;
</pre></div><p>All functions that take an integer as its first argument can be connected to the above defined signal. This implies global functions as well as all kinds of member functions where the type of the return value can be arbitrary.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If a function's signature differs from the signal's signature, a connection is still possible if the argument types can be converted to each other. For instance, the following function can still be connected to the above signal: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> function(<span class="keywordtype">double</span>); 
</pre></div></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Since version 1.2.0 it is also possible to <b> connect to functions with less parameters </b> than those given in the signature of the signal. For instance, it is also possible to connect to the above signal a slot like <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> function(); 
</pre></div></dd></dl>
<p>Up to four parameters can be specified:</p>
<div class="fragment"><pre class="fragment"> Signal&lt;arg1_type, arg2_type, arg3_type, arg4_type&gt; signal;
</pre></div><p>Now, a connection can be established as follows:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;function);              <span class="comment">// global function slot</span>
 signal.connect(&amp;<span class="keywordtype">object</span>, &amp;function);     <span class="comment">// member function slot</span>
</pre></div><p>If a signal is emitted (or send) the connected functions are called in the order they were connected to a signal. Connections can either be unique or multiple-connected. The former is the default behaviour. To change this, you can specify the connection type, for instance:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;function, <a class="code" href="namespace_t_r_t_k_1_1_signals.html#aa1f0e2efd52935fd01bfece0fbead81fadcd3d551d68cc4d609d986ddfe322cc7" title="Allows multiple connections of the same slot to a certain signal.">TRTK::Signals::MULTIPLE_CONNECTIONS</a>);
</pre></div><p>A slot is disconnected as follows:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;function);           <span class="comment">// global function slot</span>
 signal.disconnect(&amp;<span class="keywordtype">object</span>, &amp;function);  <span class="comment">// member function slot</span>
</pre></div><p>Always, the last found/connected slot is disconnected (or all slots if <code>MULTIPLE_CONNECTIONS</code> is passed as an additional argument). It follows, that the former connection order is preserved. If <code>object</code> in the former example is derived from the Receiver class, all connections are disconnected automatically during the destruction of this object. This avoids hanging references within the signal.</p>
<p>Now, we will present an example to show, how signals and slots can be used.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_clock_8hpp.html" title="This file contains the declarations of the Clock class and related functions.">TRTK/Clock.hpp</a>&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="_signals_8hpp.html" title="This file contains all classes and function related to the signal and slot concept.">TRTK/Signals.hpp</a>&gt;</span>

 <span class="keyword">using namespace </span>std;
 <span class="keyword">using namespace </span>TRTK;


 <span class="keyword">class </span>DisplayClass <span class="comment">// This could be a status bar, for instance.</span>
 {
 <span class="keyword">public</span>:
     <span class="keywordtype">void</span> print(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value)
     {
         cout &lt;&lt; value &lt;&lt; endl;
     }
 };


 <span class="keyword">class </span>CountDown
 {
 <span class="keyword">public</span>:
     CountDown(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> counter) : m_counter(counter) {}

     <span class="keywordtype">void</span> start()
     {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = m_counter; i &gt;= 0; --i)
         {
             Clock().wait_seconds(1);
             state.send(i);
         }

         finished.send();
     }

     Signal&lt;unsigned int&gt; state;
     Signal&lt;void&gt; finished;

 <span class="keyword">private</span>:
     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m_counter;
 };


 <span class="keywordtype">void</span> print()
 {
     cout &lt;&lt; <span class="stringliteral">&quot;print() was called.&quot;</span> &lt;&lt; endl;
 }


 <span class="keywordtype">int</span> main()
 {
     CountDown countDown(10);

     DisplayClass displayClass;

     countDown.state.connect(&amp;displayClass, &amp;DisplayClass::print);

     countDown.finished.connect(&amp;print);
     countDown.finished.connect(&amp;print, <a class="code" href="namespace_t_r_t_k_1_1_signals.html#aa1f0e2efd52935fd01bfece0fbead81fadcd3d551d68cc4d609d986ddfe322cc7" title="Allows multiple connections of the same slot to a certain signal.">MULTIPLE_CONNECTIONS</a>); <span class="comment">// print is called twice</span>

     countDown.start();

     <span class="comment">// The next line could be ommited, if DisplayClass was derived from Receiver.</span>
     countDown.state.disconnect(&amp;displayClass, &amp;DisplayClass::print);
     countDown.finished.connect(&amp;print, <a class="code" href="namespace_t_r_t_k_1_1_signals.html#aa1f0e2efd52935fd01bfece0fbead81fadcd3d551d68cc4d609d986ddfe322cc7" title="Allows multiple connections of the same slot to a certain signal.">MULTIPLE_CONNECTIONS</a>);

     <span class="keywordflow">return</span> 0;
 }
</pre></div><p>Output:</p>
<div class="fragment"><pre class="fragment"> 10
 9
 8
 7
 6
 5
 4
 3
 2
 1
 0
 print() was called.
 print() was called.
</pre></div><p>As we can see, now, the CountDown class is fully decoupled from its graphical representation.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><ul>
<li>For convenience reasons, the <a class="el" href="namespace_t_r_t_k_1_1_signals.html" title="This namespace contains various classes and functions related to the signals and slots implementation...">Signals</a> and the Receiver class as well as the connection types are also directly available in the <a class="el" href="namespace_t_r_t_k.html" title="Namespace of the Transformation and Registration Toolkit.">TRTK</a> namespace.</li>
<li><a class="el" href="namespace_t_r_t_k_1_1_signals.html" title="This namespace contains various classes and functions related to the signals and slots implementation...">Signals</a> can always be modified, even if they are declared <code>const</code>.</li>
</ul>
</dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Christoph Haenisch </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.2.2 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>last changed on 2014-07-03 </dd></dl>

<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01656">1656</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a80ed90f656ed40c371c311c813318269"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="a80ed90f656ed40c371c311c813318269" args="(slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to a non-static non-constant member function with four parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01677">1677</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d7fa4745926651026eea52c9a5710e6"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="a5d7fa4745926651026eea52c9a5710e6" args="(slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type, slot_arg3_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to a non-static non-constant member function with three parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01698">1698</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15044a7d84ee7f6d9098148b3200678c"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="a15044a7d84ee7f6d9098148b3200678c" args="(slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to a non-static non-constant member function with one parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01740">1740</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7f08490b0bf03f82a14798571771a2a"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="ac7f08490b0bf03f82a14798571771a2a" args="(const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type) const, ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type) const &#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to a non-static constant member function with two parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01824">1824</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a728b8f316409e4878684965c7628d601"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="a728b8f316409e4878684965c7628d601" args="(const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type) const, ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type) const &#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to a non-static constant member function with one parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01845">1845</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a898e99b9ad311c1f7db916256844ece6"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="a898e99b9ad311c1f7db916256844ece6" args="(slot_class_type *object, slot_return_type(slot_class_type::*function)(), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)()&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to a non-static non-constant member function with zero parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01761">1761</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a070cf978a4f5d224e2c33aab9f1f409d"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="a070cf978a4f5d224e2c33aab9f1f409d" args="(const slot_class_type *object, slot_return_type(slot_class_type::*function)() const, ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)() const &#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to a non-static constant member function with zero parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01866">1866</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3bdbde4689e89b3b78854d2e75cc2a08"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="a3bdbde4689e89b3b78854d2e75cc2a08" args="(slot_return_type(*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">slot_return_type(*)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects a global or a static member function with four parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01886">1886</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3bdc365987a7c35a5fbe796d5dfedb22"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="a3bdc365987a7c35a5fbe796d5dfedb22" args="(slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to a non-static non-constant member function with two parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01719">1719</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abfc4420a6542874ff352167824bf52f7"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="abfc4420a6542874ff352167824bf52f7" args="(const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type) const, ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type) const &#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to a non-static constant member function with four parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01782">1782</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9541405c1140a80a0a2c3c82684ac0b"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="ac9541405c1140a80a0a2c3c82684ac0b" args="(slot_return_type(*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">slot_return_type(*)(slot_arg1_type, slot_arg2_type, slot_arg3_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects a global or a static member function with three parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01906">1906</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace466a83528cd0cecf06426eba0cd227"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="ace466a83528cd0cecf06426eba0cd227" args="(slot_return_type(*function)(slot_arg1_type, slot_arg2_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">slot_return_type(*)(slot_arg1_type, slot_arg2_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects a global or a static member function with two parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01926">1926</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a264c818117456d0267e815f10e26443e"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="a264c818117456d0267e815f10e26443e" args="(const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type) const, ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type, slot_arg3_type) const &#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to a non-static constant member function with three parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01803">1803</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aced9b51381f86f2896fbe6bd1eafa98a"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="aced9b51381f86f2896fbe6bd1eafa98a" args="(slot_return_type(*function)(slot_arg1_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_return_type , typename slot_arg1_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">slot_return_type(*)(slot_arg1_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects a global or a static member function with one parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01946">1946</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c12995c4214be55e5da37af0585ebc5"></a><!-- doxytag: member="TRTK::Signals::Signal::connect" ref="a2c12995c4214be55e5da37af0585ebc5" args="(slot_return_type(*function)(), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_return_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">slot_return_type(*)()&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects a global or a static member function with zero parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.connect(&amp;function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01966">1966</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a61f82506ad07b320c5c42cdf3a179383"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="a61f82506ad07b320c5c42cdf3a179383" args="(slot_return_type(*function)(slot_arg1_type, slot_arg2_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">slot_return_type(*)(slot_arg1_type, slot_arg2_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a global or a static member function with two parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02300">2300</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad61a20f22681eff593377170a6e49826"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="ad61a20f22681eff593377170a6e49826" args="(slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a non-static non-constant member function with one parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02069">2069</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34998902d0b899d62fb1305fe8a499a7"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="a34998902d0b899d62fb1305fe8a499a7" args="(slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a non-static non-constant member function with four parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01991">1991</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad8e133dcbf0975b5a2a80b69f484b05b"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="ad8e133dcbf0975b5a2a80b69f484b05b" args="(slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type, slot_arg3_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a non-static non-constant member function with three parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02017">2017</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ad584ed7766aef0168e5136706564a2"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="a8ad584ed7766aef0168e5136706564a2" args="(const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type) const, ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">const slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type) const &#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a non-static constant member function with two parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02173">2173</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a35097a44ca3747c6deed3b6065961b"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="a4a35097a44ca3747c6deed3b6065961b" args="(const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type) const, ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">const slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type) const &#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a non-static constant member function with one parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02199">2199</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad48d4b4972689d9a7a551bb4e925ae0"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="aad48d4b4972689d9a7a551bb4e925ae0" args="(slot_return_type(*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">slot_return_type(*)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a global or a static member function with four parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02250">2250</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7360559edec91f5a606251ce733d6d25"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="a7360559edec91f5a606251ce733d6d25" args="(slot_return_type(*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">slot_return_type(*)(slot_arg1_type, slot_arg2_type, slot_arg3_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a global or a static member function with three parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02275">2275</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f658294c45cbde1d6dd8d71342fe190"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="a5f658294c45cbde1d6dd8d71342fe190" args="(slot_return_type(*function)(), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_return_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">slot_return_type(*)()&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a global or a static member function with zero parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02350">2350</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74e71736c2dcb7640a0f4d0e738b1ff0"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="a74e71736c2dcb7640a0f4d0e738b1ff0" args="(slot_class_type *object, slot_return_type(slot_class_type::*function)(), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)()&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a non-static non-constant member function with zero parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02095">2095</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08d9f209b0bc68fea80b1d3b5cdeb08f"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="a08d9f209b0bc68fea80b1d3b5cdeb08f" args="(slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a non-static non-constant member function with two parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02043">2043</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb80491a6fa72e9c977476e3f7f741b2"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="abb80491a6fa72e9c977476e3f7f741b2" args="(slot_return_type(*function)(slot_arg1_type), ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_return_type , typename slot_arg1_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">slot_return_type(*)(slot_arg1_type)&#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a global or a static member function with one parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02325">2325</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac39446c30733a2f97101458e13cb9a59"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="ac39446c30733a2f97101458e13cb9a59" args="(const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type) const, ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">const slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type, slot_arg3_type) const &#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a non-static constant member function with three parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02147">2147</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc5d93cded64e95f3003613cc2c0719d"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="abc5d93cded64e95f3003613cc2c0719d" args="(const slot_class_type *object, slot_return_type(slot_class_type::*function)() const, ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">const slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)() const &#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a non-static constant member function with zero parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02225">2225</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a872fdc56c547cb924ae06054ef036e4e"></a><!-- doxytag: member="TRTK::Signals::Signal::disconnect" ref="a872fdc56c547cb924ae06054ef036e4e" args="(const slot_class_type *object, slot_return_type(slot_class_type::*function)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type) const, ConnectionType connection_type=SINGLE_CONNECTION) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
<div class="memtemplate">
template&lt;typename slot_class_type , typename slot_return_type , typename slot_arg1_type , typename slot_arg2_type , typename slot_arg3_type , typename slot_arg4_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::disconnect </td>
          <td>(</td>
          <td class="paramtype">const slot_class_type *&#160;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slot_return_type(slot_class_type::*)(slot_arg1_type, slot_arg2_type, slot_arg3_type, slot_arg4_type) const &#160;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a>&#160;</td>
          <td class="paramname"> <em>connection_type</em> = <code>SINGLE_CONNECTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnects a non-static constant member function with four parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>Instance whose function shall be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_type</td><td>Type of connection.</td></tr>
  </table>
  </dd>
</dl>
<p>If connection_type is SINGLE_CONNECTION, only the last found connection is deleted. <br/>
 If connection_type is MULTIPLE_CONNECTIONS, all connections found are deleted.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> signal.disconnect(&amp;<span class="keywordtype">object</span>, &amp;class::function);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02121">2121</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24a381ac7ee44834b7ec099615a1154c"></a><!-- doxytag: member="TRTK::Signals::Signal::send" ref="a24a381ac7ee44834b7ec099615a1154c" args="(arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html">TRTK::Signals::Signal</a>&lt; arg1_type, arg2_type, arg3_type, arg4_type &gt;::send </td>
          <td>(</td>
          <td class="paramtype">arg1_type&#160;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg2_type&#160;</td>
          <td class="paramname"> <em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg3_type&#160;</td>
          <td class="paramname"> <em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg4_type&#160;</td>
          <td class="paramname"> <em>arg4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emits a signal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg1</td><td>First input argument of the called slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg2</td><td>Second input argument of the called slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg3</td><td>Third input argument of the called slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg4</td><td>Fourth input argument of the called slot.</td></tr>
  </table>
  </dd>
</dl>
<p>Currently, only up to four arguments are supported. An argument may only (and then must) be given, if the signal and the corresponding slots provide the particular signature.</p>
<p>Example:</p>
<div class="fragment"><pre class="fragment"> Signal&lt;void&gt; signal1;
 Signal&lt;string&gt; signal2;

 signal1.send();
 signal2.send(<span class="stringliteral">&quot;Some text.&quot;</span>);
</pre></div> 
<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l02380">2380</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aa1f0e2efd52935fd01bfece0fbead81f"></a><!-- doxytag: member="TRTK::Signals::Signal::ConnectionType" ref="aa1f0e2efd52935fd01bfece0fbead81f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename arg1_type  = void, typename arg2_type  = void, typename arg3_type  = void, typename arg4_type  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_t_r_t_k_1_1_signals_1_1_signal.html#aa1f0e2efd52935fd01bfece0fbead81f">ConnectionType</a><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Slot connection type. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Christoph Haenisch </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.1.0 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>last changed on 2011-08-25 </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa1f0e2efd52935fd01bfece0fbead81fadcd3d551d68cc4d609d986ddfe322cc7"></a><!-- doxytag: member="MULTIPLE_CONNECTIONS" ref="aa1f0e2efd52935fd01bfece0fbead81fadcd3d551d68cc4d609d986ddfe322cc7" args="" -->MULTIPLE_CONNECTIONS</em>&nbsp;</td><td>
<p>Allows multiple connections of the same slot to a certain signal. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa1f0e2efd52935fd01bfece0fbead81fa625aad836ed3b60cb0c295332d6554bc"></a><!-- doxytag: member="SINGLE_CONNECTION" ref="aa1f0e2efd52935fd01bfece0fbead81fa625aad836ed3b60cb0c295332d6554bc" args="" -->SINGLE_CONNECTION</em>&nbsp;</td><td>
<p>Allows only a single connection of a certain slot to a certain signal. If multiple connections were established before, the number of connections remains the same. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_signals_8hpp_source.html#l01267">1267</a> of file <a class="el" href="_signals_8hpp_source.html">Signals.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/Users/haenisch/Programmierung/TRTK/trunk/include/TRTK/<a class="el" href="_signals_8hpp_source.html">Signals.hpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/>
    <address class="footer">
        <small>
            Copyright 2010 - 2014 by Christoph Hänisch,
            Chair of Medical Engineering (mediTEC),
            RWTH Aachen University <p>
            Documentation generated by <a href="http://www.doxygen.org/index.html"> Doxygen </a>
        </small>
    </address>

</body>
</html>
