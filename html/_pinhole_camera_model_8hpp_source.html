<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Transformation and Registration Toolkit: D:/Programmierung/C/TRTK/include/TRTK/PinholeCameraModel.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<script src="../mathjax/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>D:/Programmierung/C/TRTK/include/TRTK/PinholeCameraModel.hpp</h1>  </div>
</div>
<div class="contents">
<a href="_pinhole_camera_model_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">    This class implements a simple camera model as often used in computer vision.</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    Copyright (C) 2010 - 2019 Christoph HÃ¤nisch</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">    SurgiTAIX AG</span>
<a name="l00007"></a>00007 <span class="comment">    Kaiserstr. 100, TPH 1, 2. Et.</span>
<a name="l00008"></a>00008 <span class="comment">    52134 Herzogenrath</span>
<a name="l00009"></a>00009 <span class="comment">    Germany</span>
<a name="l00010"></a>00010 <span class="comment">*/</span>
<a name="l00011"></a>00011 
<a name="l00018"></a>00018 <span class="preprocessor">#ifndef PINHOLE_CAMERA_MODEL_HPP_4231789408</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span><span class="preprocessor">#define PINHOLE_CAMERA_MODEL_HPP_4231789408</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;tuple&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;Eigen/Dense&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;Eigen/Eigenvalues&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;Eigen/Geometry&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;Eigen/SVD&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#ifdef CPPOPTLIB_FOUND</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;cppoptlib/meta.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">    #include &lt;cppoptlib/problem.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">    #include &lt;cppoptlib/solver/bfgssolver.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#endif // CPPOPTLIB_FOUND</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="_error_obj_8hpp.html" title="This file contains the declaration of the ErrorObj class.">ErrorObj.hpp</a>&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="_coordinate_8hpp.html" title="This file contains the Coordinate class and related functions.">Coordinate.hpp</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="_range_8hpp.html" title="This file contains the Range class as well as some helper functions.">Range.hpp</a>&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="keyword">namespace </span>TRTK
<a name="l00043"></a>00043 {
<a name="l00044"></a>00044 
<a name="l00045"></a>00045     <span class="comment">/**************************************************************</span>
<a name="l00046"></a>00046 <span class="comment">     *                      Helper function                       *</span>
<a name="l00047"></a>00047 <span class="comment">     **************************************************************/</span>
<a name="l00048"></a>00048 
<a name="l00073"></a>00073     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00074"></a>00074     std::tuple&lt;Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt;, Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt;&gt;
<a name="l00075"></a><a class="code" href="namespace_t_r_t_k.html#ab886c359951145f5eefa712ec159ada5">00075</a>         <a class="code" href="namespace_t_r_t_k.html#ab886c359951145f5eefa712ec159ada5" title="RQ decomposition of a square matrix.">computeRQDecomposition</a>(<span class="keyword">const</span> Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; &amp; A)
<a name="l00076"></a>00076     {
<a name="l00077"></a>00077         <span class="comment">/*</span>
<a name="l00078"></a>00078 <span class="comment">        This RQ decomposition scheme is based on the math.stackexchange article</span>
<a name="l00079"></a>00079 <span class="comment">        https://math.stackexchange.com/questions/1640695/rq-decomposition/1640762.</span>
<a name="l00080"></a>00080 <span class="comment"></span>
<a name="l00081"></a>00081 <span class="comment">        Algorithm</span>
<a name="l00082"></a>00082 <span class="comment">        =========</span>
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">        Given the square matrix A.</span>
<a name="l00085"></a>00085 <span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">        1. Define P as the exchange matrix, i.e., an anti-diagonal matrix with ones along the counter-diagonal</span>
<a name="l00087"></a>00087 <span class="comment">        2. Compute A_tilda = P * A</span>
<a name="l00088"></a>00088 <span class="comment">        3. Compute the decomposition of A_tilda^T = Q_tilda * R_tilda</span>
<a name="l00089"></a>00089 <span class="comment">        4. Set Q := P * Q_tilda^T</span>
<a name="l00090"></a>00090 <span class="comment">        5. Set R := P * R_tilda^T * P</span>
<a name="l00091"></a>00091 <span class="comment"></span>
<a name="l00092"></a>00092 <span class="comment">        Then, it holds that</span>
<a name="l00093"></a>00093 <span class="comment"></span>
<a name="l00094"></a>00094 <span class="comment">            R * Q = (P * R_tilda^T * P)(P * Q_tilda^T) = P * R_tilda^T * Q_tilda^T</span>
<a name="l00095"></a>00095 <span class="comment">                  = P * (Q_tilda * R_tilda)^T = P * (A_tilda^T)^T</span>
<a name="l00096"></a>00096 <span class="comment">                  = P * A_tilda = P * P * A = A</span>
<a name="l00097"></a>00097 <span class="comment"></span>
<a name="l00098"></a>00098 <span class="comment">        since P = P^T and P * P = I.</span>
<a name="l00099"></a>00099 <span class="comment"></span>
<a name="l00100"></a>00100 <span class="comment">        Uniqueness</span>
<a name="l00101"></a>00101 <span class="comment">        ==========</span>
<a name="l00102"></a>00102 <span class="comment"></span>
<a name="l00103"></a>00103 <span class="comment">        Eigen&#39;s Housholder QR decomposition is not unique. This can be easily rectified</span>
<a name="l00104"></a>00104 <span class="comment">        by changing QR to QDDR=(QD)(DR) where D = diag(sign(r11), ..., sign(rnn)). That</span>
<a name="l00105"></a>00105 <span class="comment">        is, a diagonal matrix D is formed whose entries are the signs of the entries of</span>
<a name="l00106"></a>00106 <span class="comment">        the main diagonal of R. Then the rows of DR are altered in such a way that the</span>
<a name="l00107"></a>00107 <span class="comment">        new diagonal entries are all positive. Since DD^T = DD = I it holds that</span>
<a name="l00108"></a>00108 <span class="comment">        (QD)(DR) = QR. Also, D is orthogonal and so is QD. Thus, the result is still a</span>
<a name="l00109"></a>00109 <span class="comment">        valid QR decomposition.</span>
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">        This circumstance is used below when computing the QR decomposition of A_tilda^T.</span>
<a name="l00112"></a>00112 <span class="comment">        */</span>
<a name="l00113"></a>00113 
<a name="l00114"></a>00114         <span class="keyword">using namespace </span>std;
<a name="l00115"></a>00115         <span class="keyword">using namespace </span>Eigen;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117         <span class="keyword">using</span> Matrix = Eigen::Matrix&lt;T, Dynamic, Dynamic&gt;;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119         <span class="keyword">const</span> <span class="keywordtype">bool</span> INPUT_MATRIX_SQUARE = A.cols() == A.rows();
<a name="l00120"></a>00120         assert(INPUT_MATRIX_SQUARE);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         <span class="keyword">const</span> <span class="keywordtype">int</span> n = (int) A.cols();
<a name="l00123"></a>00123 
<a name="l00124"></a>00124         Matrix P = Matrix::Zero(n, n);
<a name="l00125"></a>00125         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; ++i) P(n-1-i, i) = 1;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         Matrix A_tilda = P * A;  <span class="comment">// reverse rows of A</span>
<a name="l00128"></a>00128         HouseholderQR&lt;Matrix&gt; qr(A_tilda.transpose());
<a name="l00129"></a>00129         Matrix Q_tilda = qr.householderQ();
<a name="l00130"></a>00130         Matrix R_tilda = qr.matrixQR().triangularView&lt;Upper&gt;();
<a name="l00131"></a>00131         DiagonalMatrix&lt;T, Dynamic, Dynamic&gt; D(n);
<a name="l00132"></a>00132         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) D.diagonal()(i) = R_tilda(i, i) &gt;= 0 ? 1 : -1;
<a name="l00133"></a>00133         Q_tilda = Q_tilda * D;
<a name="l00134"></a>00134         R_tilda = D * R_tilda; <span class="comment">// make R unique by making the diagonal entries positive</span>
<a name="l00135"></a>00135         Matrix Q = P * Q_tilda.transpose();
<a name="l00136"></a>00136         Matrix R = P * R_tilda.transpose() * P;  <span class="comment">// reverse rows and columns of R_tilda</span>
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         <span class="keyword">const</span> <span class="keywordtype">bool</span> Q_IS_ORTHOGONAL = (Q * Q.transpose() - Matrix::Identity(n, n)).norm() &lt; 1e-7;
<a name="l00139"></a>00139         assert(Q_IS_ORTHOGONAL);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141         <span class="keywordflow">return</span> make_pair(R, Q);
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 
<a name="l00145"></a>00145     <span class="comment">/**************************************************************</span>
<a name="l00146"></a>00146 <span class="comment">     *                     PinholeCameraModel                     *</span>
<a name="l00147"></a>00147 <span class="comment">     **************************************************************/</span>
<a name="l00148"></a>00148 
<a name="l00347"></a>00347     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00348"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html">00348</a>     <span class="keyword">class </span><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel</a>
<a name="l00349"></a>00349     {
<a name="l00350"></a>00350     <span class="keyword">public</span>:
<a name="l00351"></a>00351         <span class="keyword">enum</span> Error {
<a name="l00352"></a>00352             NOT_ENOUGH_INPUT_DATA,
<a name="l00353"></a>00353             UNEQUAL_CARDINALITY_OF_INPUT_SETS,
<a name="l00354"></a>00354             UNKNOWN_ESTIMATION_METHOD,
<a name="l00355"></a>00355             <a class="code" href="namespace_t_r_t_k_1_1_diffusion.html#a638f7cf0e236aab0d2b425895589e488a8133c47c038ecaf0018ab9a7a4a449ea" title="An unknown error occurred.">UNKNOWN_ERROR</a>
<a name="l00356"></a>00356         };
<a name="l00357"></a>00357 
<a name="l00358"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#adaf5e05a5d1d1af5afe755fc831d10b8">00358</a>         <span class="keyword">enum</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#adaf5e05a5d1d1af5afe755fc831d10b8">Constraints</a> {                          
<a name="l00359"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#adaf5e05a5d1d1af5afe755fc831d10b8adb797f33de6c63cde77cb09e72beea6a">00359</a>             <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#adaf5e05a5d1d1af5afe755fc831d10b8adb797f33de6c63cde77cb09e72beea6a" title="Constraints w.r.t. the projection matrix.">NO_SKEW</a>,                                
<a name="l00360"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#adaf5e05a5d1d1af5afe755fc831d10b8a56136b7a441c65ac770807d10bd66ae1">00360</a>             <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#adaf5e05a5d1d1af5afe755fc831d10b8a56136b7a441c65ac770807d10bd66ae1" title="The focal lengths are assumed to be equal to each other.">SAME_FOCAL_LENGTHS</a>,                     
<a name="l00361"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#adaf5e05a5d1d1af5afe755fc831d10b8a7c3be7130fba06b8ce2f913af706841d">00361</a>             <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#adaf5e05a5d1d1af5afe755fc831d10b8a7c3be7130fba06b8ce2f913af706841d" title="The focal lengths are assumed to be equal to each other and there is no skewed image plane...">SAME_FOCAL_LENGTHS_AND_NO_SKEW</a>,         
<a name="l00362"></a>00362         };
<a name="l00363"></a>00363 
<a name="l00364"></a>00364         <span class="keyword">using</span> value_type = T;
<a name="l00365"></a>00365         <span class="keyword">using</span> Vector2T =  Eigen::Matrix&lt;T, 2, 1&gt;;
<a name="l00366"></a>00366         <span class="keyword">using</span> Vector3T =  Eigen::Matrix&lt;T, 3, 1&gt;;
<a name="l00367"></a>00367         <span class="keyword">using</span> Vector4T =  Eigen::Matrix&lt;T, 4, 1&gt;;
<a name="l00368"></a>00368         <span class="keyword">using</span> VectorXT =  Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt;;
<a name="l00369"></a>00369         <span class="keyword">using</span> Matrix3T =  Eigen::Matrix&lt;T, 3, 3&gt;;
<a name="l00370"></a>00370         <span class="keyword">using</span> Matrix34T =  Eigen::Matrix&lt;T, 3, 4&gt;;
<a name="l00371"></a>00371         <span class="keyword">using</span> Matrix4T =  Eigen::Matrix&lt;T, 4, 4&gt;;
<a name="l00372"></a>00372         <span class="keyword">using</span> MatrixXT =  Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt;;
<a name="l00373"></a>00373         <span class="keyword">using</span> Point =  <a class="code" href="class_t_r_t_k_1_1_coordinate.html" title="A generic coordinate class.">Coordinate&lt;T&gt;</a>;
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel</a>();                              
<a name="l00376"></a>00376         <span class="keyword">virtual</span> ~<a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel</a>();                     
<a name="l00377"></a>00377 
<a name="l00378"></a>00378         <span class="comment">// Getters</span>
<a name="l00379"></a>00379 
<a name="l00380"></a>00380         Vector3T getCameraPosition() <span class="keyword">const</span>;         
<a name="l00381"></a>00381         Matrix3T getCameraOrientation() <span class="keyword">const</span>;      
<a name="l00382"></a>00382 
<a name="l00383"></a>00383         Matrix4T getExtrinsicParameters() <span class="keyword">const</span>;    
<a name="l00384"></a>00384         Matrix34T getIntrinsicParameters() <span class="keyword">const</span>;   
<a name="l00385"></a>00385         Matrix34T getCameraParameters() <span class="keyword">const</span>;      
<a name="l00386"></a>00386 
<a name="l00387"></a>00387         std::tuple&lt;T, T&gt; getFocalLengths() <span class="keyword">const</span>;   
<a name="l00388"></a>00388         std::tuple&lt;T, T&gt; getImageCenter() <span class="keyword">const</span>;    
<a name="l00389"></a>00389         T getSkew() <span class="keyword">const</span>;                          
<a name="l00390"></a>00390 
<a name="l00391"></a>00391         <span class="comment">// Setters</span>
<a name="l00392"></a>00392 
<a name="l00393"></a>00393         <span class="keywordtype">void</span> setCameraPosition(<span class="keyword">const</span> Vector3T &amp; position);          
<a name="l00394"></a>00394         <span class="keywordtype">void</span> setCameraOrientation(<span class="keyword">const</span> Matrix3T &amp; orientation);    
<a name="l00395"></a>00395 
<a name="l00396"></a>00396         <span class="keywordtype">void</span> setExtrinsicParameters(<span class="keyword">const</span> Matrix4T &amp; parameters);   
<a name="l00397"></a>00397         <span class="keywordtype">void</span> setIntrinsicParameters(<span class="keyword">const</span> Matrix34T &amp; parameters);  
<a name="l00398"></a>00398 
<a name="l00399"></a>00399         <span class="keywordtype">void</span> setFocalLengths(T f_x, T f_y);                         
<a name="l00400"></a>00400         <span class="keywordtype">void</span> setImageCenter(T c_x, T c_y);                          
<a name="l00401"></a>00401         <span class="keywordtype">void</span> setSkew(T skew);                                       
<a name="l00402"></a>00402 
<a name="l00403"></a>00403         <span class="comment">// Other methods</span>
<a name="l00404"></a>00404 
<a name="l00405"></a>00405         Vector2T operator*(<span class="keyword">const</span> Vector3T &amp; point) <span class="keyword">const</span>;           
<a name="l00406"></a>00406         Vector2T transform(<span class="keyword">const</span> Vector3T &amp; point) <span class="keyword">const</span>;           
<a name="l00407"></a>00407 
<a name="l00408"></a>00408         T estimate(<span class="keyword">const</span> <a class="code" href="class_t_r_t_k_1_1_range.html" title="Aggregate of two input iterator adapters.">Range&lt;Vector3T&gt;</a> &amp; points_world, <span class="keyword">const</span> <a class="code" href="class_t_r_t_k_1_1_range.html" title="Aggregate of two input iterator adapters.">Range&lt;Vector2T&gt;</a> &amp; points_display);   
<a name="l00409"></a>00409 
<a name="l00410"></a>00410 <span class="preprocessor">        #ifdef CPPOPTLIB_FOUND</span>
<a name="l00411"></a>00411 <span class="preprocessor"></span>            T estimateWithConstraints(<span class="keyword">const</span> <a class="code" href="class_t_r_t_k_1_1_range.html" title="Aggregate of two input iterator adapters.">Range&lt;Vector3T&gt;</a> &amp; points_world, <span class="keyword">const</span> <a class="code" href="class_t_r_t_k_1_1_range.html" title="Aggregate of two input iterator adapters.">Range&lt;Vector2T&gt;</a> &amp; points_display, Constraints constraints = SAME_FOCAL_LENGTHS_AND_NO_SKEW, <span class="keywordtype">bool</span> initialize = <span class="keyword">true</span>, <span class="keywordtype">bool</span> constrained_decomposition = <span class="keyword">true</span>);   
<a name="l00412"></a>00412 <span class="preprocessor">        #endif // CPPOPTLIB_FOUND</span>
<a name="l00413"></a>00413 <span class="preprocessor"></span>
<a name="l00414"></a>00414     <span class="keyword">private</span>:
<a name="l00415"></a>00415         Matrix4T T_pose = Matrix4T::Identity();
<a name="l00416"></a>00416         Matrix34T T_proj = Matrix34T::Identity();
<a name="l00417"></a>00417     };
<a name="l00418"></a>00418 
<a name="l00419"></a>00419 
<a name="l00420"></a>00420     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00421"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a5c02b462bd0a34fb89ca1eae6983fb3e">00421</a>     <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::PinholeCameraModel</a>()
<a name="l00422"></a>00422     {
<a name="l00423"></a>00423     }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425 
<a name="l00426"></a>00426     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00427"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a91a38296822b2bbd7c7c8d689bdcd241">00427</a>     <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::~PinholeCameraModel</a>()
<a name="l00428"></a>00428     {
<a name="l00429"></a>00429     }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 
<a name="l00495"></a>00495     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00496"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a1766f296e40aa7e8da411e569048bb02">00496</a>     T <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::estimate</a>(<span class="keyword">const</span> <a class="code" href="class_t_r_t_k_1_1_range.html" title="Aggregate of two input iterator adapters.">Range&lt;Vector3T&gt;</a> &amp; points_world, <span class="keyword">const</span> <a class="code" href="class_t_r_t_k_1_1_range.html" title="Aggregate of two input iterator adapters.">Range&lt;Vector2T&gt;</a> &amp; points_display)
<a name="l00497"></a>00497     {
<a name="l00498"></a>00498         <span class="comment">/*</span>
<a name="l00499"></a>00499 <span class="comment"></span>
<a name="l00500"></a>00500 <span class="comment">        Three different implementations were tested. First variant 1 as described in [4] which</span>
<a name="l00501"></a>00501 <span class="comment">        worked fine for noise-free data but was very unstable for noisy data---especially w.r.t.</span>
<a name="l00502"></a>00502 <span class="comment">        the decomposition. Both variants 2 and 3 were described in [5] and are much more stable</span>
<a name="l00503"></a>00503 <span class="comment">        in the presence of noise. Also the RMSE is much lower and the decomposition yields</span>
<a name="l00504"></a>00504 <span class="comment">        reasonable values. Variant 3 is possibly numerically slightly less stable than variant 2</span>
<a name="l00505"></a>00505 <span class="comment">        but is much faster and thus the final choice.</span>
<a name="l00506"></a>00506 <span class="comment"></span>
<a name="l00507"></a>00507 <span class="comment">        All three implementation are kept in this header file for documentation purposes.</span>
<a name="l00508"></a>00508 <span class="comment"></span>
<a name="l00509"></a>00509 <span class="comment"></span>
<a name="l00510"></a>00510 <span class="comment">        References</span>
<a name="l00511"></a>00511 <span class="comment">        ==========</span>
<a name="l00512"></a>00512 <span class="comment"></span>
<a name="l00513"></a>00513 <span class="comment">        [1] Hartley and Zisserman, &quot;Multiple view geometry in computer vision&quot;, 2003</span>
<a name="l00514"></a>00514 <span class="comment"></span>
<a name="l00515"></a>00515 <span class="comment">        [2] Szeliski, &quot;Computer Vision - Algorithms and Applications&quot;, 2011, Springer</span>
<a name="l00516"></a>00516 <span class="comment"></span>
<a name="l00517"></a>00517 <span class="comment">        [3] Sutherland, &quot;Three-Dimensional Data Input by Tablet&quot;, 1974, IEEE</span>
<a name="l00518"></a>00518 <span class="comment"></span>
<a name="l00519"></a>00519 <span class="comment">        [4] Tuceryan et al., &quot;Single point active alignment method (SPAAM) for optical</span>
<a name="l00520"></a>00520 <span class="comment">            see-through HMD calibration for AR&quot;, 2000, IEEE</span>
<a name="l00521"></a>00521 <span class="comment"></span>
<a name="l00522"></a>00522 <span class="comment">        [5] Carl Olsson, Computer Vision, &quot;Lecture 3: Camera Calibration, DLT, SVD&quot;, 2014,</span>
<a name="l00523"></a>00523 <span class="comment">            http://www.maths.lth.se/matematiklth/personal/calle/datorseende14/notes/forelas3.pdf</span>
<a name="l00524"></a>00524 <span class="comment"></span>
<a name="l00525"></a>00525 <span class="comment">        */</span>
<a name="l00526"></a>00526 
<a name="l00527"></a>00527         <span class="keyword">using namespace </span>std;
<a name="l00528"></a>00528         <span class="keyword">using namespace </span>Eigen;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530         <span class="comment">// Check for assertions.</span>
<a name="l00531"></a>00531 
<a name="l00532"></a>00532         <span class="keywordtype">int</span> number_of_points = (int) points_world.<a class="code" href="class_t_r_t_k_1_1_range.html#a10f58af635fed97f331229fc4a518912" title="Returns the size of the sequence.">size</a>();
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         <span class="keywordflow">if</span> (points_world.<a class="code" href="class_t_r_t_k_1_1_range.html#a10f58af635fed97f331229fc4a518912" title="Returns the size of the sequence.">size</a>() != points_display.<a class="code" href="class_t_r_t_k_1_1_range.html#a10f58af635fed97f331229fc4a518912" title="Returns the size of the sequence.">size</a>())
<a name="l00535"></a>00535         {
<a name="l00536"></a>00536             <a class="code" href="class_t_r_t_k_1_1_error_obj.html" title="Error class that incorporates additional information.">ErrorObj</a> error;
<a name="l00537"></a>00537             error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a7581fa0d8725f2e6a9fc8412946898e0" title="Sets the class name (this should be the name of the class in which ErrorObj is thrown).">setClassName</a>(<span class="stringliteral">&quot;PinholeCameraModel&lt;T&gt;&quot;</span>);
<a name="l00538"></a>00538             error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#aabb82023e284b6735162abe0feb5cc58" title="Sets the function name (this should be the name of the function in which ErrorObj is thrown)...">setFunctionName</a>(<span class="stringliteral">&quot;estimate&quot;</span>);
<a name="l00539"></a>00539             error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a815faa194d64ee4fb969f213fc6d4a53" title="Sets the error message.">setErrorMessage</a>(<span class="stringliteral">&quot;Set sizes do not match.&quot;</span>);
<a name="l00540"></a>00540             error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a0a06daae496fb7007da711c44b84b1e7" title="Sets the error code.">setErrorCode</a>(UNEQUAL_CARDINALITY_OF_INPUT_SETS);
<a name="l00541"></a>00541             <span class="keywordflow">throw</span> error;
<a name="l00542"></a>00542         }
<a name="l00543"></a>00543 
<a name="l00544"></a>00544         <span class="keywordflow">if</span> (number_of_points &lt; 6)
<a name="l00545"></a>00545         {
<a name="l00546"></a>00546             <a class="code" href="class_t_r_t_k_1_1_error_obj.html" title="Error class that incorporates additional information.">ErrorObj</a> error;
<a name="l00547"></a>00547             error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a7581fa0d8725f2e6a9fc8412946898e0" title="Sets the class name (this should be the name of the class in which ErrorObj is thrown).">setClassName</a>(<span class="stringliteral">&quot;PinholeCameraModel&lt;T&gt;&quot;</span>);
<a name="l00548"></a>00548             error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#aabb82023e284b6735162abe0feb5cc58" title="Sets the function name (this should be the name of the function in which ErrorObj is thrown)...">setFunctionName</a>(<span class="stringliteral">&quot;estimate&quot;</span>);
<a name="l00549"></a>00549             error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a815faa194d64ee4fb969f213fc6d4a53" title="Sets the error message.">setErrorMessage</a>(<span class="stringliteral">&quot;Not enough points (6) to estimate the camera parameters.&quot;</span>);
<a name="l00550"></a>00550             error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a0a06daae496fb7007da711c44b84b1e7" title="Sets the error code.">setErrorCode</a>(NOT_ENOUGH_INPUT_DATA);
<a name="l00551"></a>00551             <span class="keywordflow">throw</span> error;
<a name="l00552"></a>00552         }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554         <span class="keyword">enum</span> Variants
<a name="l00555"></a>00555         {
<a name="l00556"></a>00556             VARIANT1,   <span class="comment">// Tuceryan (or Sutherland but formulated as a null-space problem)</span>
<a name="l00557"></a>00557             VARIANT2,   <span class="comment">// Olsson (estimation of scaling factors)</span>
<a name="l00558"></a>00558             VARIANT3    <span class="comment">// Olsson (cross product)</span>
<a name="l00559"></a>00559         } variant = VARIANT3;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         Matrix34T A; <span class="comment">// camera matrix to be estimated by one of the following variants and then to be decomposed</span>
<a name="l00562"></a>00562 
<a name="l00563"></a>00563         <span class="keywordflow">switch</span>(variant)
<a name="l00564"></a>00564         {
<a name="l00565"></a>00565             <span class="keywordflow">case</span> VARIANT1:
<a name="l00566"></a>00566             {
<a name="l00567"></a>00567                 <span class="comment">/*</span>
<a name="l00568"></a>00568 <span class="comment"></span>
<a name="l00569"></a>00569 <span class="comment">                This implementation is based on the work of Tuceryan et al. [4]. The QR decomposition</span>
<a name="l00570"></a>00570 <span class="comment">                is not mentioned in the paper, but solving for the equations manually as described in</span>
<a name="l00571"></a>00571 <span class="comment">                [5] yields the exact same results (this was thoroughly tested). Note, the parameter</span>
<a name="l00572"></a>00572 <span class="comment">                names and variable names do slightly vary from this article. The algorithm is</span>
<a name="l00573"></a>00573 <span class="comment">                essentially the same as the direct linear transformation algorithm as described in [3].</span>
<a name="l00574"></a>00574 <span class="comment"></span>
<a name="l00575"></a>00575 <span class="comment"></span>
<a name="l00576"></a>00576 <span class="comment">                Algorithm</span>
<a name="l00577"></a>00577 <span class="comment">                =========</span>
<a name="l00578"></a>00578 <span class="comment"></span>
<a name="l00579"></a>00579 <span class="comment">                Given: N corresponding point pairs (x&#39;_i, y&#39;_i) and (x_i, y_i, z_i)</span>
<a name="l00580"></a>00580 <span class="comment"></span>
<a name="l00581"></a>00581 <span class="comment">                The projection can be described with the following relation</span>
<a name="l00582"></a>00582 <span class="comment"></span>
<a name="l00583"></a>00583 <span class="comment">                    p&#39; ~ T_proj * T_pose * p = A * p    (where A = [a_ij])</span>
<a name="l00584"></a>00584 <span class="comment"></span>
<a name="l00585"></a>00585 <span class="comment">                or written-out</span>
<a name="l00586"></a>00586 <span class="comment"></span>
<a name="l00587"></a>00587 <span class="comment">                    | x&#39; |     | u |     | fx  tau  cx  0 |     | r11  r12  r13  t1 |     | x |</span>
<a name="l00588"></a>00588 <span class="comment">                    | y&#39; |  ~  | v |  =  | 0   fy   cy  0 |  *  | r21  r22  r23  t2 |  *  | y |     (1)</span>
<a name="l00589"></a>00589 <span class="comment">                    | 1  |     | w |     | 0   0    1   0 |     | r31  r32  r33  t3 |     | z |</span>
<a name="l00590"></a>00590 <span class="comment">                                                                | 0    0    0    1  |     | 1 |.</span>
<a name="l00591"></a>00591 <span class="comment"></span>
<a name="l00592"></a>00592 <span class="comment">                The resulting vector (x&#39;, y&#39;, 1) equals the right side of the relation up</span>
<a name="l00593"></a>00593 <span class="comment">                to a scaling factor. Due to the normalization properties of homogeneous</span>
<a name="l00594"></a>00594 <span class="comment">                coordinates it holds that</span>
<a name="l00595"></a>00595 <span class="comment"></span>
<a name="l00596"></a>00596 <span class="comment">                    x&#39; = u / w      (2)</span>
<a name="l00597"></a>00597 <span class="comment">                    y&#39; = v / w.</span>
<a name="l00598"></a>00598 <span class="comment"></span>
<a name="l00599"></a>00599 <span class="comment">                Rearranging equation (2) and inserting equation (1) into it yields</span>
<a name="l00600"></a>00600 <span class="comment"></span>
<a name="l00601"></a>00601 <span class="comment">                    u = x&#39; * w   &lt;==&gt;   a11 * x + a12 * y + a13 * z + a14 = x&#39; * (a31 * x + a32 * y + a33 * z + a34)    (3)</span>
<a name="l00602"></a>00602 <span class="comment">                    v = y&#39; * w   &lt;==&gt;   a21 * x + a22 * y + a23 * z + a24 = y&#39; * (a31 * x + a32 * y + a33 * z + a34)</span>
<a name="l00603"></a>00603 <span class="comment"></span>
<a name="l00604"></a>00604 <span class="comment">                By defining a vector c := (a11, a12, ..., a34)^T with the sough coefficients</span>
<a name="l00605"></a>00605 <span class="comment">                equation (3) can again be rewritten to</span>
<a name="l00606"></a>00606 <span class="comment"></span>
<a name="l00607"></a>00607 <span class="comment">                    B * c = 0</span>
<a name="l00608"></a>00608 <span class="comment"></span>
<a name="l00609"></a>00609 <span class="comment">                where</span>
<a name="l00610"></a>00610 <span class="comment"></span>
<a name="l00611"></a>00611 <span class="comment">                    B  =  | x  y  z  1  0  0  0  0  -x&#39;x  -x&#39;y  -x&#39;z  -x&#39; |     (4)</span>
<a name="l00612"></a>00612 <span class="comment">                          | 0  0  0  0  x  y  z  1  -y&#39;x  -y&#39;y  -y&#39;z  -y&#39; |.</span>
<a name="l00613"></a>00613 <span class="comment"></span>
<a name="l00614"></a>00614 <span class="comment">                Actually, B must be formed from all measurements B = [B_1^T, B_2^T, ..., B_N^T]^T.</span>
<a name="l00615"></a>00615 <span class="comment">                Here, the indices were dropped for ease in notation.</span>
<a name="l00616"></a>00616 <span class="comment"></span>
<a name="l00617"></a>00617 <span class="comment">                Now, the sought parameters can be found as the null-space of B. For this, a</span>
<a name="l00618"></a>00618 <span class="comment">                Lagrange function L := || B * c ||^2 - lambda (|| c ||^2  - 1) is defined and</span>
<a name="l00619"></a>00619 <span class="comment">                minimized. This can be justified with the fact that projection matrices (and</span>
<a name="l00620"></a>00620 <span class="comment">                thus also the vector c) may be arbitrarily scaled without changing their</span>
<a name="l00621"></a>00621 <span class="comment">                properties. Hence, c might be constrained to have a magnitude of 1 to avoid the</span>
<a name="l00622"></a>00622 <span class="comment">                trivial solution. This leads to an eigenvalue problem which can be solved in a</span>
<a name="l00623"></a>00623 <span class="comment">                numerically more stable way using a singular value decomposition (SVD). Then, c</span>
<a name="l00624"></a>00624 <span class="comment">                is the singular vector associated with the smallest singular value of V with</span>
<a name="l00625"></a>00625 <span class="comment">                B = U * S * V^T.</span>
<a name="l00626"></a>00626 <span class="comment"></span>
<a name="l00627"></a>00627 <span class="comment">                Finally, the matrix A must be decomposed into the projection matrix T_proj and</span>
<a name="l00628"></a>00628 <span class="comment">                the pose matrix T_pose. Using block matrices equation (1) can also be written as</span>
<a name="l00629"></a>00629 <span class="comment"></span>
<a name="l00630"></a>00630 <span class="comment">                    | U  0 |  *  | R    t |  =  | UR  Ut |  =  A      (5)</span>
<a name="l00631"></a>00631 <span class="comment">                                 | 0^T  1 |</span>
<a name="l00632"></a>00632 <span class="comment"></span>
<a name="l00633"></a>00633 <span class="comment">                where U is the left part of T_proj (which is an upper triangular 3-by-3 matrix)</span>
<a name="l00634"></a>00634 <span class="comment">                and where R is the upper left 3-by-3 sub-matrix of T_pose which is orthogonal; t</span>
<a name="l00635"></a>00635 <span class="comment">                is the 3d translation vector of T_pose. That is, U * R is the left 3-by-3 matrix</span>
<a name="l00636"></a>00636 <span class="comment">                of A and a product of an upper triangular matrix and an orthogonal matrix. This</span>
<a name="l00637"></a>00637 <span class="comment">                can be factorized with the RQ algorithm (similar to the QR algorithm). The</span>
<a name="l00638"></a>00638 <span class="comment">                remaining variables can then be easily computed.</span>
<a name="l00639"></a>00639 <span class="comment"></span>
<a name="l00640"></a>00640 <span class="comment">                Note, not every implementation of the QR / RQ algorithm returns a unique upper</span>
<a name="l00641"></a>00641 <span class="comment">                triangular matrix. The above implementation does this by returning a triangular</span>
<a name="l00642"></a>00642 <span class="comment">                matrix whose diagonals are always positive. This is in accordance with the</span>
<a name="l00643"></a>00643 <span class="comment">                projection matrix of the pinhole camera model where both focal lengths are</span>
<a name="l00644"></a>00644 <span class="comment">                assumed to be positive.</span>
<a name="l00645"></a>00645 <span class="comment"></span>
<a name="l00646"></a>00646 <span class="comment">                Note, U may be arbitrarily scaled and should be normalized in such a way that</span>
<a name="l00647"></a>00647 <span class="comment">                the coefficient u33 is equal to 1 (as is the case in the above definition of</span>
<a name="l00648"></a>00648 <span class="comment">                the projection matrix).</span>
<a name="l00649"></a>00649 <span class="comment"></span>
<a name="l00650"></a>00650 <span class="comment">                */</span>
<a name="l00651"></a>00651 
<a name="l00652"></a>00652                 <span class="comment">// Form the matrix B.</span>
<a name="l00653"></a>00653 
<a name="l00654"></a>00654                 MatrixXT B;
<a name="l00655"></a>00655                 B.resize(2 * number_of_points, 12);
<a name="l00656"></a>00656                 <span class="keywordtype">int</span> i = 0;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp; p_W : points_world)
<a name="l00659"></a>00659                 {
<a name="l00660"></a>00660                     <span class="keyword">auto</span> &amp; x = p_W.x();
<a name="l00661"></a>00661                     <span class="keyword">auto</span> &amp; y = p_W.y();
<a name="l00662"></a>00662                     <span class="keyword">auto</span> &amp; z = p_W.z();
<a name="l00663"></a>00663 
<a name="l00664"></a>00664                     <span class="keyword">auto</span> <span class="keyword">const</span> &amp; p_D = points_display.<a class="code" href="class_t_r_t_k_1_1_range.html#a9c11802aea4e7f605c0892951d57d46e" title="Returns the current element of the range traversal.">currentItem</a>();
<a name="l00665"></a>00665                     <span class="keyword">auto</span> &amp; x_dash = p_D.x();
<a name="l00666"></a>00666                     <span class="keyword">auto</span> &amp; y_dash = p_D.y();
<a name="l00667"></a>00667                     points_display.<a class="code" href="class_t_r_t_k_1_1_range.html#a2d4b767c82c1f706cfe32f4ce8d3e2f1" title="Selects the next element in the range.">next</a>();
<a name="l00668"></a>00668 
<a name="l00669"></a>00669                     B(i,  0) = x;
<a name="l00670"></a>00670                     B(i,  1) = y;
<a name="l00671"></a>00671                     B(i,  2) = z;
<a name="l00672"></a>00672                     B(i,  3) = 1;
<a name="l00673"></a>00673                     B(i,  4) = 0;
<a name="l00674"></a>00674                     B(i,  5) = 0;
<a name="l00675"></a>00675                     B(i,  6) = 0;
<a name="l00676"></a>00676                     B(i,  7) = 0;
<a name="l00677"></a>00677                     B(i,  8) = -x_dash * x;
<a name="l00678"></a>00678                     B(i,  9) = -x_dash * y;
<a name="l00679"></a>00679                     B(i, 10) = -x_dash * z;
<a name="l00680"></a>00680                     B(i, 11) = -x_dash;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682                     B(i+1,  0) = 0;
<a name="l00683"></a>00683                     B(i+1,  1) = 0;
<a name="l00684"></a>00684                     B(i+1,  2) = 0;
<a name="l00685"></a>00685                     B(i+1,  3) = 0;
<a name="l00686"></a>00686                     B(i+1,  4) = x;
<a name="l00687"></a>00687                     B(i+1,  5) = y;
<a name="l00688"></a>00688                     B(i+1,  6) = z;
<a name="l00689"></a>00689                     B(i+1,  7) = 1;
<a name="l00690"></a>00690                     B(i+1,  8) = -y_dash * x;
<a name="l00691"></a>00691                     B(i+1,  9) = -y_dash * y;
<a name="l00692"></a>00692                     B(i+1, 10) = -y_dash * z;
<a name="l00693"></a>00693                     B(i+1, 11) = -y_dash;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695                     i = i + 2;
<a name="l00696"></a>00696                 }
<a name="l00697"></a>00697 
<a name="l00698"></a>00698                 <span class="comment">// Compute the parameter vector c and rearrange c to A.</span>
<a name="l00699"></a>00699 
<a name="l00700"></a>00700                 JacobiSVD&lt;MatrixXT&gt; svd(B, ComputeThinV);
<a name="l00701"></a>00701                 VectorXT c = svd.matrixV().col(svd.matrixV().cols() - 1);
<a name="l00702"></a>00702                 A = Map&lt;Matrix&lt;T, 3, 4, RowMajor&gt;&gt;(c.data());
<a name="l00703"></a>00703 
<a name="l00704"></a>00704                 <span class="keywordflow">break</span>;
<a name="l00705"></a>00705             }
<a name="l00706"></a>00706 
<a name="l00707"></a>00707             <span class="keywordflow">case</span> VARIANT2: <span class="comment">// estimate projection matrix and scale factors</span>
<a name="l00708"></a>00708             {
<a name="l00709"></a>00709                 <span class="comment">/*</span>
<a name="l00710"></a>00710 <span class="comment"></span>
<a name="l00711"></a>00711 <span class="comment">                This implementation is based on the computer vision lecture notes of Carl Olsson [5].</span>
<a name="l00712"></a>00712 <span class="comment">                The RQ decomposition differs from the description found in the lecture notes, but</span>
<a name="l00713"></a>00713 <span class="comment">                solving for the equations manually as described in [5] yields the exact same results</span>
<a name="l00714"></a>00714 <span class="comment">                (this was thoroughly tested). Note, the parameter names and variable names may vary</span>
<a name="l00715"></a>00715 <span class="comment">                from the reference.</span>
<a name="l00716"></a>00716 <span class="comment"></span>
<a name="l00717"></a>00717 <span class="comment"></span>
<a name="l00718"></a>00718 <span class="comment">                Algorithm</span>
<a name="l00719"></a>00719 <span class="comment">                =========</span>
<a name="l00720"></a>00720 <span class="comment"></span>
<a name="l00721"></a>00721 <span class="comment">                Given: N corresponding point pairs (x&#39;_i, y&#39;_i) and (x_i, y_i, z_i)</span>
<a name="l00722"></a>00722 <span class="comment"></span>
<a name="l00723"></a>00723 <span class="comment">                The projection can be described with the following relation</span>
<a name="l00724"></a>00724 <span class="comment"></span>
<a name="l00725"></a>00725 <span class="comment">                    p&#39;_i ~ T_proj * T_pose * p_i = A * p_i    (where A = [a_kl])</span>
<a name="l00726"></a>00726 <span class="comment"></span>
<a name="l00727"></a>00727 <span class="comment">                or</span>
<a name="l00728"></a>00728 <span class="comment"></span>
<a name="l00729"></a>00729 <span class="comment">                    lambda_i * p&#39;_i = A * p_i       (1)</span>
<a name="l00730"></a>00730 <span class="comment"></span>
<a name="l00731"></a>00731 <span class="comment">                using an unknown scaling factor lambda_i. With</span>
<a name="l00732"></a>00732 <span class="comment"></span>
<a name="l00733"></a>00733 <span class="comment">                        | A1^T |                    | x&#39;_i |</span>
<a name="l00734"></a>00734 <span class="comment">                    A = | A2^T |      and    p&#39;_i = | y&#39;_i |</span>
<a name="l00735"></a>00735 <span class="comment">                        | A3^T |                    | z&#39;_i |</span>
<a name="l00736"></a>00736 <span class="comment"></span>
<a name="l00737"></a>00737 <span class="comment">                equation (1) can be rewritten as</span>
<a name="l00738"></a>00738 <span class="comment"></span>
<a name="l00739"></a>00739 <span class="comment">                    p_i^T * A1 - lambda_i * x&#39;_i = 0</span>
<a name="l00740"></a>00740 <span class="comment">                    p_i^T * A2 - lambda_i * y&#39;_i = 0</span>
<a name="l00741"></a>00741 <span class="comment">                    p_i^T * A3 - lambda_i * z&#39;_i = 0</span>
<a name="l00742"></a>00742 <span class="comment"></span>
<a name="l00743"></a>00743 <span class="comment">                or in matrix notation  (z&#39;_i = 1 due to the normalization)</span>
<a name="l00744"></a>00744 <span class="comment"></span>
<a name="l00745"></a>00745 <span class="comment">                    | p_i^T   0       0       -x&#39;_i |     | A1       |     | 0 |</span>
<a name="l00746"></a>00746 <span class="comment">                    | 0       p_i^T   0       -y&#39;_i |  *  | A2       |  =  | 0 |</span>
<a name="l00747"></a>00747 <span class="comment">                    | 0       0       p_i^T   -1    |     | A3       |     | 0 |.</span>
<a name="l00748"></a>00748 <span class="comment">                                                          | lambda_i |</span>
<a name="l00749"></a>00749 <span class="comment"></span>
<a name="l00750"></a>00750 <span class="comment">                For multiple entries we then have</span>
<a name="l00751"></a>00751 <span class="comment"></span>
<a name="l00752"></a>00752 <span class="comment">                    | p_1^T   0       0       -x&#39;_1   0       0       ... |</span>
<a name="l00753"></a>00753 <span class="comment">                    | 0       p_1^T   0       -y&#39;_1   0       0       ... |     | A1       |</span>
<a name="l00754"></a>00754 <span class="comment">                    | 0       0       p_1^T   -1      0       0       ... |     | A2       |</span>
<a name="l00755"></a>00755 <span class="comment">                    | p_2^T   0       0       0       -x&#39;_2   0       ... |     | A3       |</span>
<a name="l00756"></a>00756 <span class="comment">                    | 0       p_2^T   0       0       -y&#39;_2   0       ... |  *  | lambda_1 |  =  0.</span>
<a name="l00757"></a>00757 <span class="comment">                    | 0       0       p_2^T   0       -1      0       ... |     | lambda_2 |</span>
<a name="l00758"></a>00758 <span class="comment">                    | p_3^T   0       0       0       0       -x&#39;_3   ... |     | lambda_3 |</span>
<a name="l00759"></a>00759 <span class="comment">                    | 0       p_3^T   0       0       0       -y&#39;_3   ... |     | ...      |</span>
<a name="l00760"></a>00760 <span class="comment">                    | 0       0       p_3^T   0       0       -1      ... |</span>
<a name="l00761"></a>00761 <span class="comment">                    | ...     ...     ...     ...     ...     ...     ... |</span>
<a name="l00762"></a>00762 <span class="comment"></span>
<a name="l00763"></a>00763 <span class="comment">                Or</span>
<a name="l00764"></a>00764 <span class="comment"></span>
<a name="l00765"></a>00765 <span class="comment">                    M * c = 0.</span>
<a name="l00766"></a>00766 <span class="comment"></span>
<a name="l00767"></a>00767 <span class="comment">                Now, the sought parameters can be found as the null-space of M. For this, a</span>
<a name="l00768"></a>00768 <span class="comment">                Lagrange function L := || M * c ||^2 - lambda (|| c ||^2  - 1) is defined and</span>
<a name="l00769"></a>00769 <span class="comment">                minimized. This can be justified with the fact that projection matrices (and</span>
<a name="l00770"></a>00770 <span class="comment">                thus also the vector c) may be arbitrarily scaled without changing their</span>
<a name="l00771"></a>00771 <span class="comment">                properties. Hence, c might be constrained to have a magnitude of 1 to avoid the</span>
<a name="l00772"></a>00772 <span class="comment">                trivial solution. This leads to an eigenvalue problem which can be solved in a</span>
<a name="l00773"></a>00773 <span class="comment">                numerically more stable way using a singular value decomposition (SVD). Then, c</span>
<a name="l00774"></a>00774 <span class="comment">                is the singular vector associated with the smallest singular value of V with</span>
<a name="l00775"></a>00775 <span class="comment">                B = U * S * V^T.</span>
<a name="l00776"></a>00776 <span class="comment"></span>
<a name="l00777"></a>00777 <span class="comment">                Finally, the matrix A must be decomposed into the projection matrix T_proj and</span>
<a name="l00778"></a>00778 <span class="comment">                the pose matrix T_pose. Using block matrices equation (1) can also be written as</span>
<a name="l00779"></a>00779 <span class="comment"></span>
<a name="l00780"></a>00780 <span class="comment">                    | U  0 |  *  | R    t |  =  | UR  Ut |  =  A      (5)</span>
<a name="l00781"></a>00781 <span class="comment">                                 | 0^T  1 |</span>
<a name="l00782"></a>00782 <span class="comment"></span>
<a name="l00783"></a>00783 <span class="comment">                where U is the left part of T_proj (which is an upper triangular 3-by-3 matrix)</span>
<a name="l00784"></a>00784 <span class="comment">                and where R is the upper left 3-by-3 sub-matrix of T_pose which is orthogonal; t</span>
<a name="l00785"></a>00785 <span class="comment">                is the 3d translation vector of T_pose. That is, U * R is the left 3-by-3 matrix</span>
<a name="l00786"></a>00786 <span class="comment">                of A and a product of an upper triangular matrix and an orthogonal matrix. This</span>
<a name="l00787"></a>00787 <span class="comment">                can be factorized with the RQ algorithm (similar to the QR algorithm). The</span>
<a name="l00788"></a>00788 <span class="comment">                remaining variables can then be easily computed.</span>
<a name="l00789"></a>00789 <span class="comment"></span>
<a name="l00790"></a>00790 <span class="comment">                Note, not every implementation of the QR / RQ algorithm returns a unique upper</span>
<a name="l00791"></a>00791 <span class="comment">                triangular matrix. The above implementation does this by returning a triangular</span>
<a name="l00792"></a>00792 <span class="comment">                matrix whose diagonals are always positive. This is in accordance with the</span>
<a name="l00793"></a>00793 <span class="comment">                projection matrix of the pinhole camera model where both focal lengths are</span>
<a name="l00794"></a>00794 <span class="comment">                assumed to be positive.</span>
<a name="l00795"></a>00795 <span class="comment"></span>
<a name="l00796"></a>00796 <span class="comment">                Note, U may be arbitrarily scaled and should be normalized in such a way that</span>
<a name="l00797"></a>00797 <span class="comment">                the coefficient u33 is equal to 1 (as is the case in the above definition of</span>
<a name="l00798"></a>00798 <span class="comment">                the projection matrix).</span>
<a name="l00799"></a>00799 <span class="comment"></span>
<a name="l00800"></a>00800 <span class="comment">                */</span>
<a name="l00801"></a>00801 
<a name="l00802"></a>00802                 <span class="comment">// Form the matrix M.</span>
<a name="l00803"></a>00803 
<a name="l00804"></a>00804                 MatrixXT M = MatrixXT::Zero(3 * number_of_points, 12 + number_of_points);
<a name="l00805"></a>00805                 <span class="keywordtype">int</span> i = 0;
<a name="l00806"></a>00806 
<a name="l00807"></a>00807                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp; p_W : points_world)
<a name="l00808"></a>00808                 {
<a name="l00809"></a>00809                     <span class="keyword">auto</span> <span class="keyword">const</span> &amp; p_D = points_display.<a class="code" href="class_t_r_t_k_1_1_range.html#a9c11802aea4e7f605c0892951d57d46e" title="Returns the current element of the range traversal.">currentItem</a>();
<a name="l00810"></a>00810                     <span class="keyword">auto</span> &amp; x = p_D.x();
<a name="l00811"></a>00811                     <span class="keyword">auto</span> &amp; y = p_D.y();
<a name="l00812"></a>00812                     points_display.<a class="code" href="class_t_r_t_k_1_1_range.html#a2d4b767c82c1f706cfe32f4ce8d3e2f1" title="Selects the next element in the range.">next</a>();
<a name="l00813"></a>00813 
<a name="l00814"></a>00814                     M.block&lt;1, 4&gt;(3 * i + 0, 0) = p_W.homogeneous();
<a name="l00815"></a>00815                     M.block&lt;1, 4&gt;(3 * i + 1, 4) = p_W.homogeneous();
<a name="l00816"></a>00816                     M.block&lt;1, 4&gt;(3 * i + 2, 8) = p_W.homogeneous();
<a name="l00817"></a>00817 
<a name="l00818"></a>00818                     M(3 * i + 0, 12 + i) = -x;
<a name="l00819"></a>00819                     M(3 * i + 1, 12 + i) = -y;
<a name="l00820"></a>00820                     M(3 * i + 2, 12 + i) = -1;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822                     ++i;
<a name="l00823"></a>00823                 }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825                 <span class="comment">// Compute the parameter vector c and rearrange c to A.</span>
<a name="l00826"></a>00826 
<a name="l00827"></a>00827                 BDCSVD&lt;MatrixXT&gt; svd(M, ComputeThinV);
<a name="l00828"></a>00828                 VectorXT c = svd.matrixV().col(svd.matrixV().cols() - 1);
<a name="l00829"></a>00829                 A = Map&lt;Matrix&lt;T, 3, 4, RowMajor&gt;&gt;(c.data());
<a name="l00830"></a>00830 
<a name="l00831"></a>00831                 <span class="keywordflow">break</span>;
<a name="l00832"></a>00832             }
<a name="l00833"></a>00833 
<a name="l00834"></a>00834             <span class="keywordflow">case</span> VARIANT3: <span class="comment">// cross-product</span>
<a name="l00835"></a>00835             {
<a name="l00836"></a>00836                 <span class="comment">/*</span>
<a name="l00837"></a>00837 <span class="comment"></span>
<a name="l00838"></a>00838 <span class="comment">                This implementation is based on the computer vision lecture notes of Carl Olsson [5].</span>
<a name="l00839"></a>00839 <span class="comment">                The RQ decomposition differs from the description found in the lecture notes, but</span>
<a name="l00840"></a>00840 <span class="comment">                solving for the equations manually as described in [5] yields the exact same results</span>
<a name="l00841"></a>00841 <span class="comment">                (this was thoroughly tested). Note, the parameter names and variable names may vary</span>
<a name="l00842"></a>00842 <span class="comment">                from the reference.</span>
<a name="l00843"></a>00843 <span class="comment"></span>
<a name="l00844"></a>00844 <span class="comment"></span>
<a name="l00845"></a>00845 <span class="comment">                Algorithm</span>
<a name="l00846"></a>00846 <span class="comment">                =========</span>
<a name="l00847"></a>00847 <span class="comment"></span>
<a name="l00848"></a>00848 <span class="comment">                Given: N corresponding point pairs (x&#39;_i, y&#39;_i) and (x_i, y_i, z_i)</span>
<a name="l00849"></a>00849 <span class="comment"></span>
<a name="l00850"></a>00850 <span class="comment">                The projection can be described with the following relation</span>
<a name="l00851"></a>00851 <span class="comment"></span>
<a name="l00852"></a>00852 <span class="comment">                    p&#39;_i ~ T_proj * T_pose * p_i = A * p_i    (where A = [a_kl])</span>
<a name="l00853"></a>00853 <span class="comment"></span>
<a name="l00854"></a>00854 <span class="comment">                or</span>
<a name="l00855"></a>00855 <span class="comment"></span>
<a name="l00856"></a>00856 <span class="comment">                    lambda_i * p&#39;_i = A * p_i       (1)</span>
<a name="l00857"></a>00857 <span class="comment"></span>
<a name="l00858"></a>00858 <span class="comment">                using an unknown scaling factor lambda_i. Stated in other words, the vectors p&#39;_i and</span>
<a name="l00859"></a>00859 <span class="comment">                A * p_i are parallel to each other. This can be stated more formally using the cross</span>
<a name="l00860"></a>00860 <span class="comment">                product</span>
<a name="l00861"></a>00861 <span class="comment"></span>
<a name="l00862"></a>00862 <span class="comment">                    p&#39;_i  x  A * p_i  =  0.         (2)</span>
<a name="l00863"></a>00863 <span class="comment"></span>
<a name="l00864"></a>00864 <span class="comment">                By setting</span>
<a name="l00865"></a>00865 <span class="comment"></span>
<a name="l00866"></a>00866 <span class="comment">                        | A1^T |                    | x&#39;_i |</span>
<a name="l00867"></a>00867 <span class="comment">                    A = | A2^T |      and    p&#39;_i = | y&#39;_i |</span>
<a name="l00868"></a>00868 <span class="comment">                        | A3^T |                    | z&#39;_i |</span>
<a name="l00869"></a>00869 <span class="comment"></span>
<a name="l00870"></a>00870 <span class="comment">                equation (2) can be rewritten as</span>
<a name="l00871"></a>00871 <span class="comment"></span>
<a name="l00872"></a>00872 <span class="comment">                    |  y&#39;_i * A3^T * p_i  -  z&#39;_i * A2^T * p_i  |</span>
<a name="l00873"></a>00873 <span class="comment">                    |  z&#39;_i * A1^T * p_i  -  x&#39;_i * A3^T * p_i  |  =  0.</span>
<a name="l00874"></a>00874 <span class="comment">                    |  x&#39;_i * A2^T * p_i  -  y&#39;_i * A1^T * p_i  |</span>
<a name="l00875"></a>00875 <span class="comment"></span>
<a name="l00876"></a>00876 <span class="comment">                With z_i = 1 it can again be rewritten as</span>
<a name="l00877"></a>00877 <span class="comment"></span>
<a name="l00878"></a>00878 <span class="comment">                    |  0           -1 * p_i     y&#39; * p_i   |     | A1 |</span>
<a name="l00879"></a>00879 <span class="comment">                    |  1 * p_i      0           -x&#39; * p_i  |  *  | A2 |  =  0</span>
<a name="l00880"></a>00880 <span class="comment">                    |  -y&#39; * p_i    x&#39; * p_i    0          |     | A3 |</span>
<a name="l00881"></a>00881 <span class="comment"></span>
<a name="l00882"></a>00882 <span class="comment">                or</span>
<a name="l00883"></a>00883 <span class="comment"></span>
<a name="l00884"></a>00884 <span class="comment">                    M_i * c = 0.</span>
<a name="l00885"></a>00885 <span class="comment"></span>
<a name="l00886"></a>00886 <span class="comment">                For multiple entries we then have</span>
<a name="l00887"></a>00887 <span class="comment"></span>
<a name="l00888"></a>00888 <span class="comment">                        | M1  |</span>
<a name="l00889"></a>00889 <span class="comment">                    M = | M2  |.</span>
<a name="l00890"></a>00890 <span class="comment">                        | M3  |</span>
<a name="l00891"></a>00891 <span class="comment">                        | ... |</span>
<a name="l00892"></a>00892 <span class="comment"></span>
<a name="l00893"></a>00893 <span class="comment">                Now, the sought parameters can be found as the null-space of M. For this, a</span>
<a name="l00894"></a>00894 <span class="comment">                Lagrange function L := || M * c ||^2 - lambda (|| c ||^2  - 1) is defined and</span>
<a name="l00895"></a>00895 <span class="comment">                minimized. This can be justified with the fact that projection matrices (and</span>
<a name="l00896"></a>00896 <span class="comment">                thus also the vector c) may be arbitrarily scaled without changing their</span>
<a name="l00897"></a>00897 <span class="comment">                properties. Hence, c might be constrained to have a magnitude of 1 to avoid the</span>
<a name="l00898"></a>00898 <span class="comment">                trivial solution. This leads to an eigenvalue problem which can be solved in a</span>
<a name="l00899"></a>00899 <span class="comment">                numerically more stable way using a singular value decomposition (SVD). Then, c</span>
<a name="l00900"></a>00900 <span class="comment">                is the singular vector associated with the smallest singular value of V with</span>
<a name="l00901"></a>00901 <span class="comment">                B = U * S * V^T.</span>
<a name="l00902"></a>00902 <span class="comment"></span>
<a name="l00903"></a>00903 <span class="comment">                Finally, the matrix A must be decomposed into the projection matrix T_proj and</span>
<a name="l00904"></a>00904 <span class="comment">                the pose matrix T_pose. Using block matrices equation (1) can also be written as</span>
<a name="l00905"></a>00905 <span class="comment"></span>
<a name="l00906"></a>00906 <span class="comment">                    | U  0 |  *  | R    t |  =  | UR  Ut |  =  A      (5)</span>
<a name="l00907"></a>00907 <span class="comment">                                 | 0^T  1 |</span>
<a name="l00908"></a>00908 <span class="comment"></span>
<a name="l00909"></a>00909 <span class="comment">                where U is the left part of T_proj (which is an upper triangular 3-by-3 matrix)</span>
<a name="l00910"></a>00910 <span class="comment">                and where R is the upper left 3-by-3 sub-matrix of T_pose which is orthogonal; t</span>
<a name="l00911"></a>00911 <span class="comment">                is the 3d translation vector of T_pose. That is, U * R is the left 3-by-3 matrix</span>
<a name="l00912"></a>00912 <span class="comment">                of A and a product of an upper triangular matrix and an orthogonal matrix. This</span>
<a name="l00913"></a>00913 <span class="comment">                can be factorized with the RQ algorithm (similar to the QR algorithm). The</span>
<a name="l00914"></a>00914 <span class="comment">                remaining variables can then be easily computed.</span>
<a name="l00915"></a>00915 <span class="comment"></span>
<a name="l00916"></a>00916 <span class="comment">                Note, not every implementation of the QR / RQ algorithm returns a unique upper</span>
<a name="l00917"></a>00917 <span class="comment">                triangular matrix. The above implementation does this by returning a triangular</span>
<a name="l00918"></a>00918 <span class="comment">                matrix whose diagonals are always positive. This is in accordance with the</span>
<a name="l00919"></a>00919 <span class="comment">                projection matrix of the pinhole camera model where both focal lengths are</span>
<a name="l00920"></a>00920 <span class="comment">                assumed to be positive.</span>
<a name="l00921"></a>00921 <span class="comment"></span>
<a name="l00922"></a>00922 <span class="comment">                Note, U may be arbitrarily scaled and should be normalized in such a way that</span>
<a name="l00923"></a>00923 <span class="comment">                the coefficient u33 is equal to 1 (as is the case in the above definition of</span>
<a name="l00924"></a>00924 <span class="comment">                the projection matrix).</span>
<a name="l00925"></a>00925 <span class="comment"></span>
<a name="l00926"></a>00926 <span class="comment">                */</span>
<a name="l00927"></a>00927 
<a name="l00928"></a>00928                 <span class="comment">// Form the matrix M.</span>
<a name="l00929"></a>00929 
<a name="l00930"></a>00930                 MatrixXT M = MatrixXT(3 * number_of_points, 12);
<a name="l00931"></a>00931                 <span class="keywordtype">int</span> i = 0;
<a name="l00932"></a>00932 
<a name="l00933"></a>00933                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp; p_W : points_world)
<a name="l00934"></a>00934                 {
<a name="l00935"></a>00935                     <span class="keyword">auto</span> <span class="keyword">const</span> &amp; p_D = points_display.<a class="code" href="class_t_r_t_k_1_1_range.html#a9c11802aea4e7f605c0892951d57d46e" title="Returns the current element of the range traversal.">currentItem</a>();
<a name="l00936"></a>00936                     <span class="keyword">auto</span> &amp; x = p_D.x();
<a name="l00937"></a>00937                     <span class="keyword">auto</span> &amp; y = p_D.y();
<a name="l00938"></a>00938                     points_display.<a class="code" href="class_t_r_t_k_1_1_range.html#a2d4b767c82c1f706cfe32f4ce8d3e2f1" title="Selects the next element in the range.">next</a>();
<a name="l00939"></a>00939 
<a name="l00940"></a>00940                     M.block&lt;1, 4&gt;(3 * i + 0, 0).fill(0);
<a name="l00941"></a>00941                     M.block&lt;1, 4&gt;(3 * i + 0, 4) = -1 * p_W.homogeneous();
<a name="l00942"></a>00942                     M.block&lt;1, 4&gt;(3 * i + 0, 8) = y * p_W.homogeneous();
<a name="l00943"></a>00943 
<a name="l00944"></a>00944                     M.block&lt;1, 4&gt;(3 * i + 1, 0) = 1 * p_W.homogeneous();
<a name="l00945"></a>00945                     M.block&lt;1, 4&gt;(3 * i + 1, 4).fill(0);
<a name="l00946"></a>00946                     M.block&lt;1, 4&gt;(3 * i + 1, 8) = -x * p_W.homogeneous();
<a name="l00947"></a>00947 
<a name="l00948"></a>00948                     M.block&lt;1, 4&gt;(3 * i + 2, 0) = -y * p_W.homogeneous();
<a name="l00949"></a>00949                     M.block&lt;1, 4&gt;(3 * i + 2, 4) = x * p_W.homogeneous();
<a name="l00950"></a>00950                     M.block&lt;1, 4&gt;(3 * i + 2, 8).fill(0);
<a name="l00951"></a>00951 
<a name="l00952"></a>00952                     ++i;
<a name="l00953"></a>00953                 }
<a name="l00954"></a>00954 
<a name="l00955"></a>00955                 <span class="comment">// Compute the parameter vector c and rearrange c to A.</span>
<a name="l00956"></a>00956 
<a name="l00957"></a>00957                 JacobiSVD&lt;MatrixXT&gt; svd(M, ComputeThinV);
<a name="l00958"></a>00958                 VectorXT c = svd.matrixV().col(svd.matrixV().cols() - 1);
<a name="l00959"></a>00959                 A = Map&lt;Matrix&lt;T, 3, 4, RowMajor&gt;&gt;(c.data());
<a name="l00960"></a>00960 
<a name="l00961"></a>00961                 <span class="keywordflow">break</span>;
<a name="l00962"></a>00962             }
<a name="l00963"></a>00963 
<a name="l00964"></a>00964             <span class="keywordflow">default</span>:
<a name="l00965"></a>00965             {
<a name="l00966"></a>00966                 <a class="code" href="class_t_r_t_k_1_1_error_obj.html" title="Error class that incorporates additional information.">ErrorObj</a> error;
<a name="l00967"></a>00967                 error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a7581fa0d8725f2e6a9fc8412946898e0" title="Sets the class name (this should be the name of the class in which ErrorObj is thrown).">setClassName</a>(<span class="stringliteral">&quot;PinholeCameraModel&lt;T&gt;&quot;</span>);
<a name="l00968"></a>00968                 error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#aabb82023e284b6735162abe0feb5cc58" title="Sets the function name (this should be the name of the function in which ErrorObj is thrown)...">setFunctionName</a>(<span class="stringliteral">&quot;estimate&quot;</span>);
<a name="l00969"></a>00969                 error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a815faa194d64ee4fb969f213fc6d4a53" title="Sets the error message.">setErrorMessage</a>(<span class="stringliteral">&quot;Unknown estimation method.&quot;</span>);
<a name="l00970"></a>00970                 error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a0a06daae496fb7007da711c44b84b1e7" title="Sets the error code.">setErrorCode</a>(UNKNOWN_ESTIMATION_METHOD);
<a name="l00971"></a>00971                 <span class="keywordflow">throw</span> error;
<a name="l00972"></a>00972             }
<a name="l00973"></a>00973 
<a name="l00974"></a>00974         } <span class="comment">// switch(method)</span>
<a name="l00975"></a>00975 
<a name="l00976"></a>00976         <span class="comment">// Decompose A and form T_proj and T_pose from U and R according to (5).</span>
<a name="l00977"></a>00977 
<a name="l00978"></a>00978         <span class="keyword">auto</span> [U, R] = computeRQDecomposition&lt;T&gt;(A.block&lt;3, 3&gt;(0, 0));
<a name="l00979"></a>00979 
<a name="l00980"></a>00980         <span class="comment">// T_proj</span>
<a name="l00981"></a>00981         T_proj.block&lt;3, 3&gt;(0, 0) = U / U(2, 2);
<a name="l00982"></a>00982         T_proj(0, 3) = 0;
<a name="l00983"></a>00983         T_proj(1, 3) = 0;
<a name="l00984"></a>00984         T_proj(2, 3) = 0;
<a name="l00985"></a>00985 
<a name="l00986"></a>00986         <span class="comment">// T_pose</span>
<a name="l00987"></a>00987         MatrixXT Ut = A.block&lt;3, 1&gt;(0, 3);
<a name="l00988"></a>00988         MatrixXT t = U.inverse() * Ut;
<a name="l00989"></a>00989         T_pose.block&lt;3, 3&gt;(0, 0) = R;
<a name="l00990"></a>00990         T_pose.block&lt;3, 1&gt;(0, 3) = t;
<a name="l00991"></a>00991 
<a name="l00992"></a>00992         <span class="comment">// Compute the root-mean square error.</span>
<a name="l00993"></a>00993 
<a name="l00994"></a>00994         T sum_of_squared_error = 0;
<a name="l00995"></a>00995 
<a name="l00996"></a>00996         points_world.<a class="code" href="class_t_r_t_k_1_1_range.html#ae6367df45f962d9591641fa49891632c" title="Sets the internal iterator to the begin of the range.">first</a>();
<a name="l00997"></a>00997         points_display.<a class="code" href="class_t_r_t_k_1_1_range.html#ae6367df45f962d9591641fa49891632c" title="Sets the internal iterator to the begin of the range.">first</a>();
<a name="l00998"></a>00998 
<a name="l00999"></a>00999         <span class="keywordflow">while</span> (!points_world.<a class="code" href="class_t_r_t_k_1_1_range.html#ae28aaba99ec561b539b65c201bc2d5ac" title="Returns true if the traversal is done or if a sequence is empty or uninitialized.">isDone</a>())
<a name="l01000"></a>01000         {
<a name="l01001"></a>01001             <span class="keyword">auto</span> <span class="keyword">const</span> &amp; p_W = points_world.<a class="code" href="class_t_r_t_k_1_1_range.html#a9c11802aea4e7f605c0892951d57d46e" title="Returns the current element of the range traversal.">currentItem</a>();
<a name="l01002"></a>01002             <span class="keyword">auto</span> <span class="keyword">const</span> &amp; p_D = points_display.<a class="code" href="class_t_r_t_k_1_1_range.html#a9c11802aea4e7f605c0892951d57d46e" title="Returns the current element of the range traversal.">currentItem</a>();
<a name="l01003"></a>01003 
<a name="l01004"></a>01004             sum_of_squared_error += (this-&gt;transform(p_W) - p_D).squaredNorm();
<a name="l01005"></a>01005 
<a name="l01006"></a>01006             points_world.<a class="code" href="class_t_r_t_k_1_1_range.html#a2d4b767c82c1f706cfe32f4ce8d3e2f1" title="Selects the next element in the range.">next</a>();
<a name="l01007"></a>01007             points_display.<a class="code" href="class_t_r_t_k_1_1_range.html#a2d4b767c82c1f706cfe32f4ce8d3e2f1" title="Selects the next element in the range.">next</a>();
<a name="l01008"></a>01008         }
<a name="l01009"></a>01009 
<a name="l01010"></a>01010         <span class="keyword">using</span> <a class="code" href="namespace_t_r_t_k.html#ab6a8c5f73ab8b7638ca1011e6f2c89aa" title="Computes the square root of each element.">std::sqrt</a>;
<a name="l01011"></a>01011         <a class="code" href="namespace_t_r_t_k.html#ab6a8c5f73ab8b7638ca1011e6f2c89aa" title="Computes the square root of each element.">return ::sqrt</a>(sum_of_squared_error / number_of_points);
<a name="l01012"></a>01012     }
<a name="l01013"></a>01013 
<a name="l01014"></a>01014 
<a name="l01015"></a>01015 <span class="preprocessor">#ifdef CPPOPTLIB_FOUND</span>
<a name="l01016"></a>01016 <span class="preprocessor"></span>
<a name="l01116"></a>01116     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01117"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#aff2761ec861392fb0f0870fe19dcfab2">01117</a>     T <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::estimateWithConstraints</a>(<span class="keyword">const</span> <a class="code" href="class_t_r_t_k_1_1_range.html" title="Aggregate of two input iterator adapters.">Range&lt;Vector3T&gt;</a> &amp; points_world,
<a name="l01118"></a>01118                                                      <span class="keyword">const</span> <a class="code" href="class_t_r_t_k_1_1_range.html" title="Aggregate of two input iterator adapters.">Range&lt;Vector2T&gt;</a> &amp; points_display,
<a name="l01119"></a>01119                                                      <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#adaf5e05a5d1d1af5afe755fc831d10b8">Constraints</a> constraints,
<a name="l01120"></a>01120                                                      <span class="keywordtype">bool</span> initialize,
<a name="l01121"></a>01121                                                      <span class="keywordtype">bool</span> constrained_decomposition)
<a name="l01122"></a>01122     {
<a name="l01123"></a>01123         <span class="keyword">using namespace </span>std;
<a name="l01124"></a>01124         <span class="keyword">using namespace </span>Eigen;
<a name="l01125"></a>01125         <span class="keyword">using namespace </span>TRTK::Tools;
<a name="l01126"></a>01126 
<a name="l01127"></a>01127         T rmse = std::numeric_limits&lt;T&gt;::max();
<a name="l01128"></a>01128 
<a name="l01129"></a>01129         <span class="keywordflow">if</span> (initialize)
<a name="l01130"></a>01130         {
<a name="l01131"></a>01131             <span class="comment">// Estimate the camera parameters.</span>
<a name="l01132"></a>01132             T rmse = estimate(points_world, points_display);
<a name="l01133"></a>01133         }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135         <span class="comment">// Store the input point pairs in two matrices where each column represents one point.</span>
<a name="l01136"></a>01136         <span class="comment">// This makes the computation of the objective function much easier and faster (see below).</span>
<a name="l01137"></a>01137 
<a name="l01138"></a>01138         <span class="keywordtype">int</span> n = (int) points_world.<a class="code" href="class_t_r_t_k_1_1_range.html#a10f58af635fed97f331229fc4a518912" title="Returns the size of the sequence.">size</a>();
<a name="l01139"></a>01139         MatrixXT P_world(4, n);
<a name="l01140"></a>01140         MatrixXT P_display(2, n);
<a name="l01141"></a>01141         <span class="keyword">auto</span> iter_world = points_world.<a class="code" href="class_t_r_t_k_1_1_range.html#ae5e5bd7d06f7766b425ca7ed20d17855" title="Returns the first element of the range.">begin</a>();
<a name="l01142"></a>01142         <span class="keyword">auto</span> iter_display = points_display.<a class="code" href="class_t_r_t_k_1_1_range.html#ae5e5bd7d06f7766b425ca7ed20d17855" title="Returns the first element of the range.">begin</a>();
<a name="l01143"></a>01143         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i)
<a name="l01144"></a>01144         {
<a name="l01145"></a>01145             P_world.col(i) = (*(iter_world++)).homogeneous();
<a name="l01146"></a>01146             P_display.col(i) = *(iter_display++);
<a name="l01147"></a>01147         }
<a name="l01148"></a>01148 
<a name="l01149"></a>01149         <span class="keywordflow">switch</span> (constraints)
<a name="l01150"></a>01150         {
<a name="l01151"></a>01151             <span class="keywordflow">case</span> NO_SKEW:
<a name="l01152"></a>01152             {
<a name="l01153"></a>01153                 <span class="comment">// First decompose the camera matrix into the projection matrix and the pose matrix, respectively.</span>
<a name="l01154"></a>01154 
<a name="l01155"></a>01155                 VectorXT optimization_parameters;
<a name="l01156"></a>01156                 optimization_parameters.resize(10);
<a name="l01157"></a>01157 
<a name="l01158"></a>01158                 <span class="keywordflow">if</span> (constrained_decomposition)
<a name="l01159"></a>01159                 {
<a name="l01160"></a>01160                     <span class="comment">/*</span>
<a name="l01161"></a>01161 <span class="comment"></span>
<a name="l01162"></a>01162 <span class="comment">                    Decompose T_camera into T_proj and T_pose. While doing so, assume that tau = 0. Since, this</span>
<a name="l01163"></a>01163 <span class="comment">                    assumption does no hold (due to noise, etc.), the below equation only provide some</span>
<a name="l01164"></a>01164 <span class="comment">                    rough estimates which are then used as the initial values for the non-linear optimization.</span>
<a name="l01165"></a>01165 <span class="comment"></span>
<a name="l01166"></a>01166 <span class="comment"></span>
<a name="l01167"></a>01167 <span class="comment">                    | T11  T12  T13  T14 |     | fx  tau  cx  0 |     | R  t |</span>
<a name="l01168"></a>01168 <span class="comment">                    | T21  T22  T23  T24 |  =  | 0   fy   cy  0 |  *  | 0  1 |</span>
<a name="l01169"></a>01169 <span class="comment">                    | T31  T32  T33  T34 |     | 0   0    1   0 |</span>
<a name="l01170"></a>01170 <span class="comment"></span>
<a name="l01171"></a>01171 <span class="comment">                         | T11  T12  T13 |     | T1^T |     | fx  0   cx  |     | R1^T |</span>
<a name="l01172"></a>01172 <span class="comment">                    ==&gt;  | T21  T22  T23 |  =  | T2^T |  =  | 0   fy  cy  |  *  | R2^T |          (*)</span>
<a name="l01173"></a>01173 <span class="comment">                         | T31  T32  T33 |     | T3^T |     | 0   0   1   |     | R3^T |</span>
<a name="l01174"></a>01174 <span class="comment"></span>
<a name="l01175"></a>01175 <span class="comment">                         fx * R1 + cx * R3 = T1</span>
<a name="l01176"></a>01176 <span class="comment">                    ==&gt;  fy * R2 + cy * R3 = T2</span>
<a name="l01177"></a>01177 <span class="comment">                         R3 = T3</span>
<a name="l01178"></a>01178 <span class="comment"></span>
<a name="l01179"></a>01179 <span class="comment">                    Normalize T with respect to the last row: T = T / || T3 ||.</span>
<a name="l01180"></a>01180 <span class="comment"></span>
<a name="l01181"></a>01181 <span class="comment">                    With some easy algebraic manipulations we have (R1, R2, and R3 are orthogonal to each other)</span>
<a name="l01182"></a>01182 <span class="comment"></span>
<a name="l01183"></a>01183 <span class="comment">                    cx = T3^T * T1</span>
<a name="l01184"></a>01184 <span class="comment">                    cy = T3^T * T2</span>
<a name="l01185"></a>01185 <span class="comment"></span>
<a name="l01186"></a>01186 <span class="comment">                    fx * R1 = T1 - cx * T3</span>
<a name="l01187"></a>01187 <span class="comment">                    ==&gt;  fx = || T1 - cx * T3 ||</span>
<a name="l01188"></a>01188 <span class="comment">                    ==&gt; R1 = (T1 - cx * T3) / fx</span>
<a name="l01189"></a>01189 <span class="comment"></span>
<a name="l01190"></a>01190 <span class="comment">                    fy * R2 = T2 - cy * T3</span>
<a name="l01191"></a>01191 <span class="comment">                    ==&gt;  fy = || T2 - cy * T3 ||</span>
<a name="l01192"></a>01192 <span class="comment">                    ==&gt; R2 = (T2 - cy * T3) / fy</span>
<a name="l01193"></a>01193 <span class="comment"></span>
<a name="l01194"></a>01194 <span class="comment">                    R = [R1, R2, R3]^T is not necessarily orthogonal, thus a non-linear optimization has to follow.</span>
<a name="l01195"></a>01195 <span class="comment"></span>
<a name="l01196"></a>01196 <span class="comment">                    */</span>
<a name="l01197"></a>01197 
<a name="l01198"></a>01198                     <span class="keyword">auto</span> T_camera = getCameraParameters();
<a name="l01199"></a>01199 
<a name="l01200"></a>01200                     T_camera /= T_camera.block&lt;1, 3&gt;(2, 0).norm(); <span class="comment">// the last row vector shall be a unit vector</span>
<a name="l01201"></a>01201                     Vector3T T1 = T_camera.block&lt;1, 3&gt;(0, 0);
<a name="l01202"></a>01202                     Vector3T T2 = T_camera.block&lt;1, 3&gt;(1, 0);
<a name="l01203"></a>01203                     Vector3T T3 = T_camera.block&lt;1, 3&gt;(2, 0);
<a name="l01204"></a>01204                     Vector3T R3 = T3;
<a name="l01205"></a>01205                     T cx = T3.transpose() * T1;
<a name="l01206"></a>01206                     T cy = T3.transpose() * T2;
<a name="l01207"></a>01207 
<a name="l01208"></a>01208                     T fx = (T1 - cx * T3).norm();
<a name="l01209"></a>01209                     Vector3T R1 = (T1 - cx * T3) / fx;
<a name="l01210"></a>01210 
<a name="l01211"></a>01211                     T fy = (T2 - cy * T3).norm();
<a name="l01212"></a>01212                     Vector3T R2 = (T2 - cy * T3) / fy;
<a name="l01213"></a>01213 
<a name="l01214"></a>01214                     Matrix3T R;
<a name="l01215"></a>01215                     R.block&lt;1, 3&gt;(0, 0) = R1;
<a name="l01216"></a>01216                     R.block&lt;1, 3&gt;(1, 0) = R2;
<a name="l01217"></a>01217                     R.block&lt;1, 3&gt;(2, 0) = R3;
<a name="l01218"></a>01218 
<a name="l01219"></a>01219                     <span class="comment">// Orthogonalize R (guarantee right-handedness).</span>
<a name="l01220"></a>01220 
<a name="l01221"></a>01221                     <span class="keyword">auto</span> svd = JacobiSVD&lt;Matrix3T&gt;(R, ComputeFullU | ComputeFullV);
<a name="l01222"></a>01222                     R = svd.matrixU() * svd.matrixV().transpose();
<a name="l01223"></a>01223                     <span class="keywordflow">if</span> (R.determinant() &lt; 0) <span class="comment">// left-handed?</span>
<a name="l01224"></a>01224                     {
<a name="l01225"></a>01225                         MatrixXT D = MatrixXT::Identity(3, 3);
<a name="l01226"></a>01226                         D(2, 2) = -1;
<a name="l01227"></a>01227                         R = svd.matrixU() * D * svd.matrixV().transpose();
<a name="l01228"></a>01228                     }
<a name="l01229"></a>01229 
<a name="l01230"></a>01230                     <span class="comment">// Now, do the non-linear optimization. The RMSE is computed over the function (*)</span>
<a name="l01231"></a>01231                     <span class="comment">// where the rotation matrix is constructed from an axis-angle representation; the</span>
<a name="l01232"></a>01232                     <span class="comment">// unit axis is represented in spherical coordinates with only two angles/parameters.</span>
<a name="l01233"></a>01233                     <span class="comment">// Constructing a rotation matrix has the advantage that the orthogonality constraint</span>
<a name="l01234"></a>01234                     <span class="comment">// is always fulfilled.</span>
<a name="l01235"></a>01235 
<a name="l01236"></a>01236                     <span class="keyword">auto</span> [axis, rotation_angle] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a5c53f06f4479080bb50f489d83c4f8c8">axisAngleFromRotationMatrix</a>(R);
<a name="l01237"></a>01237                     <span class="keyword">auto</span> [__, axis_theta, axis_phi] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a35f674b6ab369c37820a9a3c3fbe5636">cartesian2Spherical</a>(axis.x(), axis.y(), axis.z());
<a name="l01238"></a>01238 
<a name="l01239"></a>01239                     optimization_parameters(0) = fx;
<a name="l01240"></a>01240                     optimization_parameters(1) = fy;
<a name="l01241"></a>01241                     optimization_parameters(2) = cx;
<a name="l01242"></a>01242                     optimization_parameters(3) = cy;
<a name="l01243"></a>01243                     optimization_parameters(4) = axis_theta;
<a name="l01244"></a>01244                     optimization_parameters(5) = axis_phi;
<a name="l01245"></a>01245                     optimization_parameters(6) = rotation_angle;
<a name="l01246"></a>01246                     optimization_parameters(7) = this-&gt;getCameraPosition().x();
<a name="l01247"></a>01247                     optimization_parameters(8) = this-&gt;getCameraPosition().y();
<a name="l01248"></a>01248                     optimization_parameters(9) = this-&gt;getCameraPosition().z();
<a name="l01249"></a>01249                 }
<a name="l01250"></a>01250                 <span class="keywordflow">else</span>
<a name="l01251"></a>01251                 {
<a name="l01252"></a>01252                     Matrix3T R = T_pose.block&lt;3, 3&gt;(0, 0);
<a name="l01253"></a>01253                     <span class="keyword">auto</span> [axis, rotation_angle] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a5c53f06f4479080bb50f489d83c4f8c8">axisAngleFromRotationMatrix</a>(R);
<a name="l01254"></a>01254                     <span class="keyword">auto</span> [__, axis_theta, axis_phi] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a35f674b6ab369c37820a9a3c3fbe5636">cartesian2Spherical</a>(axis.x(), axis.y(), axis.z());
<a name="l01255"></a>01255 
<a name="l01256"></a>01256                     optimization_parameters(0) = T_proj(0, 0);  <span class="comment">// fx</span>
<a name="l01257"></a>01257                     optimization_parameters(1) = T_proj(1, 1);  <span class="comment">// fy</span>
<a name="l01258"></a>01258                     optimization_parameters(2) = T_proj(0, 2);  <span class="comment">// cx</span>
<a name="l01259"></a>01259                     optimization_parameters(3) = T_proj(1, 2);  <span class="comment">// cy</span>
<a name="l01260"></a>01260                     optimization_parameters(4) = axis_theta;
<a name="l01261"></a>01261                     optimization_parameters(5) = axis_phi;
<a name="l01262"></a>01262                     optimization_parameters(6) = rotation_angle;
<a name="l01263"></a>01263                     optimization_parameters(7) = T_pose(0, 3);  <span class="comment">// tx</span>
<a name="l01264"></a>01264                     optimization_parameters(8) = T_pose(1, 3);  <span class="comment">// ty</span>
<a name="l01265"></a>01265                     optimization_parameters(9) = T_pose(2, 3);  <span class="comment">// tz</span>
<a name="l01266"></a>01266                 }
<a name="l01267"></a>01267 
<a name="l01268"></a>01268                 <span class="comment">// Now compute the constrained optimization.</span>
<a name="l01269"></a>01269 
<a name="l01270"></a>01270                 <span class="keyword">class </span>ObjectiveFunction : <span class="keyword">public</span> cppoptlib::Problem&lt;double&gt;
<a name="l01271"></a>01271                 {
<a name="l01272"></a>01272                 <span class="keyword">public</span>:
<a name="l01273"></a>01273                     <span class="keyword">using</span> <span class="keyword">typename</span> cppoptlib::Problem&lt;double&gt;::Scalar;
<a name="l01274"></a>01274                     <span class="keyword">using</span> <span class="keyword">typename</span> cppoptlib::Problem&lt;double&gt;::TVector;
<a name="l01275"></a>01275 
<a name="l01276"></a>01276                     ObjectiveFunction(<span class="keyword">const</span> MatrixXT &amp; P_world, <span class="keyword">const</span> MatrixXT &amp; P_display)
<a name="l01277"></a>01277                     {
<a name="l01278"></a>01278                         this-&gt;P_world = P_world;
<a name="l01279"></a>01279                         this-&gt;P_display = P_display;
<a name="l01280"></a>01280                     }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282                     <span class="keywordtype">double</span> value(<span class="keyword">const</span> TVector &amp; x)
<a name="l01283"></a>01283                     {
<a name="l01284"></a>01284                         T_proj = Matrix34T::Identity();
<a name="l01285"></a>01285                         T_proj(0, 0) = x(0);
<a name="l01286"></a>01286                         T_proj(1, 1) = x(1);
<a name="l01287"></a>01287                         T_proj(0, 2) = x(2);
<a name="l01288"></a>01288                         T_proj(1, 2) = x(3);
<a name="l01289"></a>01289 
<a name="l01290"></a>01290                         T_pose = Matrix4T::Identity();
<a name="l01291"></a>01291                         <span class="keyword">auto</span> axis = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a231f96eb8d68e4058ea36be09cf118a0">spherical2Cartesian</a>(Vector3T(1, x(4), x(5)));
<a name="l01292"></a>01292                         T_pose.block&lt;3, 3&gt;(0, 0) = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#ac2d049a7b10656584136d31bc2eb2f8a">rotationMatrix</a>(axis, x(6));
<a name="l01293"></a>01293                         T_pose(0, 3) = x(7);
<a name="l01294"></a>01294                         T_pose(1, 3) = x(8);
<a name="l01295"></a>01295                         T_pose(2, 3) = x(9);
<a name="l01296"></a>01296 
<a name="l01297"></a>01297                         <a class="code" href="namespace_t_r_t_k.html#ab6a8c5f73ab8b7638ca1011e6f2c89aa" title="Computes the square root of each element.">using ::sqrt</a>;
<a name="l01298"></a>01298                         MatrixXT T_camera = T_proj * T_pose;
<a name="l01299"></a>01299                         MatrixXT P_projected = (T_camera * P_world).colwise().hnormalized();
<a name="l01300"></a>01300                         T rmse = <a class="code" href="namespace_t_r_t_k.html#ab6a8c5f73ab8b7638ca1011e6f2c89aa" title="Computes the square root of each element.">sqrt</a>((P_display - P_projected).colwise().squaredNorm().<a class="code" href="namespace_t_r_t_k_1_1_tools.html#a7dc4e90beeb8b34adeebc533dfa95e00" title="Returns the mean of all container elements.">mean</a>());
<a name="l01301"></a>01301                         <span class="keywordflow">return</span> rmse;
<a name="l01302"></a>01302                     }
<a name="l01303"></a>01303 
<a name="l01304"></a>01304                 <span class="keyword">public</span>:
<a name="l01305"></a>01305                     MatrixXT P_world;
<a name="l01306"></a>01306                     MatrixXT P_display;
<a name="l01307"></a>01307                     Matrix34T T_proj;
<a name="l01308"></a>01308                     Matrix4T T_pose;
<a name="l01309"></a>01309                 };
<a name="l01310"></a>01310 
<a name="l01311"></a>01311                 <span class="keyword">auto</span> func = ObjectiveFunction(P_world, P_display);
<a name="l01312"></a>01312                 cppoptlib::BfgsSolver&lt;ObjectiveFunction&gt; solver;
<a name="l01313"></a>01313                 solver.minimize(func, optimization_parameters);
<a name="l01314"></a>01314                 T_proj = func.T_proj;
<a name="l01315"></a>01315                 T_pose = func.T_pose;
<a name="l01316"></a>01316                 rmse = func.value(optimization_parameters);
<a name="l01317"></a>01317 
<a name="l01318"></a>01318                 <span class="keywordflow">break</span>;
<a name="l01319"></a>01319             }
<a name="l01320"></a>01320 
<a name="l01321"></a>01321             <span class="keywordflow">case</span> SAME_FOCAL_LENGTHS:
<a name="l01322"></a>01322             {
<a name="l01323"></a>01323                 <span class="comment">// First decompose the camera matrix into the projection matrix and the pose matrix, respectively.</span>
<a name="l01324"></a>01324 
<a name="l01325"></a>01325                 VectorXT optimization_parameters;
<a name="l01326"></a>01326                 optimization_parameters.resize(10);
<a name="l01327"></a>01327 
<a name="l01328"></a>01328                 <span class="keywordflow">if</span> (constrained_decomposition)
<a name="l01329"></a>01329                 {
<a name="l01330"></a>01330                     <span class="comment">/*</span>
<a name="l01331"></a>01331 <span class="comment"></span>
<a name="l01332"></a>01332 <span class="comment">                    Decompose T_camera into T_proj and T_pose. While doing so, assume that f := f_x = f_y.</span>
<a name="l01333"></a>01333 <span class="comment">                    Since, this assumption does no hold (due to noise, etc.), the below equations only provide</span>
<a name="l01334"></a>01334 <span class="comment">                    some rough estimates which are then used as the initial values for the non-linear optimization.</span>
<a name="l01335"></a>01335 <span class="comment"></span>
<a name="l01336"></a>01336 <span class="comment"></span>
<a name="l01337"></a>01337 <span class="comment">                    | T11  T12  T13  T14 |     | fx  tau  cx  0 |     | R  t |</span>
<a name="l01338"></a>01338 <span class="comment">                    | T21  T22  T23  T24 |  =  | 0   fy   cy  0 |  *  | 0  1 |</span>
<a name="l01339"></a>01339 <span class="comment">                    | T31  T32  T33  T34 |     | 0   0    1   0 |</span>
<a name="l01340"></a>01340 <span class="comment"></span>
<a name="l01341"></a>01341 <span class="comment">                         | T11  T12  T13 |     | T1^T |     | f  tau  cx  |     | R1^T |</span>
<a name="l01342"></a>01342 <span class="comment">                    ==&gt;  | T21  T22  T23 |  =  | T2^T |  =  | 0  f    cy  |  *  | R2^T |          (***)</span>
<a name="l01343"></a>01343 <span class="comment">                         | T31  T32  T33 |     | T3^T |     | 0  0    1   |     | R3^T |</span>
<a name="l01344"></a>01344 <span class="comment"></span>
<a name="l01345"></a>01345 <span class="comment">                         f * R1 + tau * R2 + cx * R3 = T1</span>
<a name="l01346"></a>01346 <span class="comment">                    ==&gt;  f * R2 + cy * R3 = T2</span>
<a name="l01347"></a>01347 <span class="comment">                         R3 = T3</span>
<a name="l01348"></a>01348 <span class="comment"></span>
<a name="l01349"></a>01349 <span class="comment">                    Normalize T with respect to the last row: T = T / || T3 ||.</span>
<a name="l01350"></a>01350 <span class="comment"></span>
<a name="l01351"></a>01351 <span class="comment">                    With some easy algebraic manipulations we have (R1, R2, and R3 are orthogonal to each other)</span>
<a name="l01352"></a>01352 <span class="comment"></span>
<a name="l01353"></a>01353 <span class="comment">                    cx = T3^T * T1</span>
<a name="l01354"></a>01354 <span class="comment">                    cy = T3^T * T2</span>
<a name="l01355"></a>01355 <span class="comment"></span>
<a name="l01356"></a>01356 <span class="comment">                    f * R2 = T2 - cy * T3</span>
<a name="l01357"></a>01357 <span class="comment">                    ==&gt;  f = || T2 - cy * T3 ||</span>
<a name="l01358"></a>01358 <span class="comment">                    ==&gt; R2 = (T2 - cy * T3) / f</span>
<a name="l01359"></a>01359 <span class="comment"></span>
<a name="l01360"></a>01360 <span class="comment">                    tau * R2 = T1 - f * R1 - cx * T3</span>
<a name="l01361"></a>01361 <span class="comment">                    ==&gt; tau = R2^T * (T1 - f * R1 - cx * T3) = R2^T * T1</span>
<a name="l01362"></a>01362 <span class="comment">                    ==&gt; R1 = T1 - tau * R2 - cx * T3    (also normalize R1..)</span>
<a name="l01363"></a>01363 <span class="comment"></span>
<a name="l01364"></a>01364 <span class="comment">                    R = [R1, R2, R3]^T is not necessarily orthogonal, thus a non-linear optimization is still necessary.</span>
<a name="l01365"></a>01365 <span class="comment"></span>
<a name="l01366"></a>01366 <span class="comment">                    */</span>
<a name="l01367"></a>01367 
<a name="l01368"></a>01368                     <span class="keyword">auto</span> T_camera = getCameraParameters();
<a name="l01369"></a>01369 
<a name="l01370"></a>01370                     T_camera /= T_camera.block&lt;1, 3&gt;(2, 0).norm(); <span class="comment">// the last row vector shall be a unit vector</span>
<a name="l01371"></a>01371                     Vector3T T1 = T_camera.block&lt;1, 3&gt;(0, 0);
<a name="l01372"></a>01372                     Vector3T T2 = T_camera.block&lt;1, 3&gt;(1, 0);
<a name="l01373"></a>01373                     Vector3T T3 = T_camera.block&lt;1, 3&gt;(2, 0);
<a name="l01374"></a>01374                     Vector3T R3 = T3;
<a name="l01375"></a>01375                     T cx = T3.transpose() * T1;
<a name="l01376"></a>01376                     T cy = T3.transpose() * T2;
<a name="l01377"></a>01377 
<a name="l01378"></a>01378                     T f = (T2 - cy * T3).norm();
<a name="l01379"></a>01379                     Vector3T R2 = (T2 - cy * T3) / f;
<a name="l01380"></a>01380 
<a name="l01381"></a>01381                     T tau = R2.transpose() * T1;
<a name="l01382"></a>01382                     Vector3T R1 = (T1 - tau * R2 - cx * T3).normalized();
<a name="l01383"></a>01383 
<a name="l01384"></a>01384                     Matrix3T R;
<a name="l01385"></a>01385                     R.block&lt;1, 3&gt;(0, 0) = R1;
<a name="l01386"></a>01386                     R.block&lt;1, 3&gt;(1, 0) = R2;
<a name="l01387"></a>01387                     R.block&lt;1, 3&gt;(2, 0) = R3;
<a name="l01388"></a>01388 
<a name="l01389"></a>01389                     <span class="comment">// Orthogonalize R (guarantee right-handedness).</span>
<a name="l01390"></a>01390 
<a name="l01391"></a>01391                     <span class="keyword">auto</span> svd = JacobiSVD&lt;Matrix3T&gt;(R, ComputeFullU | ComputeFullV);
<a name="l01392"></a>01392                     R = svd.matrixU() * svd.matrixV().transpose();
<a name="l01393"></a>01393                     <span class="keywordflow">if</span> (R.determinant() &lt; 0) <span class="comment">// left-handed?</span>
<a name="l01394"></a>01394                     {
<a name="l01395"></a>01395                         MatrixXT D = MatrixXT::Identity(3, 3);
<a name="l01396"></a>01396                         D(2, 2) = -1;
<a name="l01397"></a>01397                         R = svd.matrixU() * D * svd.matrixV().transpose();
<a name="l01398"></a>01398                     }
<a name="l01399"></a>01399 
<a name="l01400"></a>01400                     <span class="comment">// Now, do the non-linear optimization. The RMSE is computed over the function (***)</span>
<a name="l01401"></a>01401                     <span class="comment">// where the rotation matrix is constructed from an axis-angle representation; the</span>
<a name="l01402"></a>01402                     <span class="comment">// unit axis is represented in spherical coordinates with only two angles/parameters.</span>
<a name="l01403"></a>01403                     <span class="comment">// Constructing a rotation matrix has the advantage that the orthogonality constraint</span>
<a name="l01404"></a>01404                     <span class="comment">// is always fulfilled.</span>
<a name="l01405"></a>01405 
<a name="l01406"></a>01406                     <span class="keyword">auto</span> [axis, rotation_angle] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a5c53f06f4479080bb50f489d83c4f8c8">axisAngleFromRotationMatrix</a>(R);
<a name="l01407"></a>01407                     <span class="keyword">auto</span> [__, axis_theta, axis_phi] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a35f674b6ab369c37820a9a3c3fbe5636">cartesian2Spherical</a>(axis.x(), axis.y(), axis.z());
<a name="l01408"></a>01408 
<a name="l01409"></a>01409                     optimization_parameters(0) = f;
<a name="l01410"></a>01410                     optimization_parameters(1) = tau;
<a name="l01411"></a>01411                     optimization_parameters(2) = cx;
<a name="l01412"></a>01412                     optimization_parameters(3) = cy;
<a name="l01413"></a>01413                     optimization_parameters(4) = axis_theta;
<a name="l01414"></a>01414                     optimization_parameters(5) = axis_phi;
<a name="l01415"></a>01415                     optimization_parameters(6) = rotation_angle;
<a name="l01416"></a>01416                     optimization_parameters(7) = this-&gt;getCameraPosition().x();
<a name="l01417"></a>01417                     optimization_parameters(8) = this-&gt;getCameraPosition().y();
<a name="l01418"></a>01418                     optimization_parameters(9) = this-&gt;getCameraPosition().z();
<a name="l01419"></a>01419                 }
<a name="l01420"></a>01420                 <span class="keywordflow">else</span>
<a name="l01421"></a>01421                 {
<a name="l01422"></a>01422                     Matrix3T R = T_pose.block&lt;3, 3&gt;(0, 0);
<a name="l01423"></a>01423                     <span class="keyword">auto</span> [axis, rotation_angle] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a5c53f06f4479080bb50f489d83c4f8c8">axisAngleFromRotationMatrix</a>(R);
<a name="l01424"></a>01424                     <span class="keyword">auto</span> [__, axis_theta, axis_phi] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a35f674b6ab369c37820a9a3c3fbe5636">cartesian2Spherical</a>(axis.x(), axis.y(), axis.z());
<a name="l01425"></a>01425 
<a name="l01426"></a>01426                     optimization_parameters(0) = 0.5 * (T_proj(0, 0) + T_proj(1, 1));  <span class="comment">// f = (fx + fy) / 2</span>
<a name="l01427"></a>01427                     optimization_parameters(1) = T_proj(0, 1);  <span class="comment">// tau</span>
<a name="l01428"></a>01428                     optimization_parameters(2) = T_proj(0, 2);  <span class="comment">// cx</span>
<a name="l01429"></a>01429                     optimization_parameters(3) = T_proj(1, 2);  <span class="comment">// cy</span>
<a name="l01430"></a>01430                     optimization_parameters(4) = axis_theta;
<a name="l01431"></a>01431                     optimization_parameters(5) = axis_phi;
<a name="l01432"></a>01432                     optimization_parameters(6) = rotation_angle;
<a name="l01433"></a>01433                     optimization_parameters(7) = T_pose(0, 3);  <span class="comment">// tx</span>
<a name="l01434"></a>01434                     optimization_parameters(8) = T_pose(1, 3);  <span class="comment">// ty</span>
<a name="l01435"></a>01435                     optimization_parameters(9) = T_pose(2, 3);  <span class="comment">// tz</span>
<a name="l01436"></a>01436                 }
<a name="l01437"></a>01437 
<a name="l01438"></a>01438                 <span class="comment">// Now compute the constrained optimization.</span>
<a name="l01439"></a>01439 
<a name="l01440"></a>01440                 <span class="keyword">class </span>ObjectiveFunction : <span class="keyword">public</span> cppoptlib::Problem&lt;double&gt;
<a name="l01441"></a>01441                 {
<a name="l01442"></a>01442                 <span class="keyword">public</span>:
<a name="l01443"></a>01443                     <span class="keyword">using</span> <span class="keyword">typename</span> cppoptlib::Problem&lt;double&gt;::Scalar;
<a name="l01444"></a>01444                     <span class="keyword">using</span> <span class="keyword">typename</span> cppoptlib::Problem&lt;double&gt;::TVector;
<a name="l01445"></a>01445 
<a name="l01446"></a>01446                     ObjectiveFunction(<span class="keyword">const</span> MatrixXT &amp; P_world, <span class="keyword">const</span> MatrixXT &amp; P_display)
<a name="l01447"></a>01447                     {
<a name="l01448"></a>01448                         this-&gt;P_world = P_world;
<a name="l01449"></a>01449                         this-&gt;P_display = P_display;
<a name="l01450"></a>01450                     }
<a name="l01451"></a>01451 
<a name="l01452"></a>01452                     <span class="keywordtype">double</span> value(<span class="keyword">const</span> TVector &amp; x)
<a name="l01453"></a>01453                     {
<a name="l01454"></a>01454                         T_proj = Matrix34T::Identity();
<a name="l01455"></a>01455                         T_proj(0, 0) = x(0);
<a name="l01456"></a>01456                         T_proj(0, 1) = x(1);
<a name="l01457"></a>01457                         T_proj(0, 2) = x(2);
<a name="l01458"></a>01458                         T_proj(1, 1) = x(0);
<a name="l01459"></a>01459                         T_proj(1, 2) = x(3);
<a name="l01460"></a>01460 
<a name="l01461"></a>01461                         T_pose = Matrix4T::Identity();
<a name="l01462"></a>01462                         <span class="keyword">auto</span> axis = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a231f96eb8d68e4058ea36be09cf118a0">spherical2Cartesian</a>(Vector3T(1, x(4), x(5)));
<a name="l01463"></a>01463                         T_pose.block&lt;3, 3&gt;(0, 0) = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#ac2d049a7b10656584136d31bc2eb2f8a">rotationMatrix</a>(axis, x(6));
<a name="l01464"></a>01464                         T_pose(0, 3) = x(7);
<a name="l01465"></a>01465                         T_pose(1, 3) = x(8);
<a name="l01466"></a>01466                         T_pose(2, 3) = x(9);
<a name="l01467"></a>01467 
<a name="l01468"></a>01468                         <a class="code" href="namespace_t_r_t_k.html#ab6a8c5f73ab8b7638ca1011e6f2c89aa" title="Computes the square root of each element.">using ::sqrt</a>;
<a name="l01469"></a>01469                         MatrixXT T_camera = T_proj * T_pose;
<a name="l01470"></a>01470                         MatrixXT P_projected = (T_camera * P_world).colwise().hnormalized();
<a name="l01471"></a>01471                         T rmse = <a class="code" href="namespace_t_r_t_k.html#ab6a8c5f73ab8b7638ca1011e6f2c89aa" title="Computes the square root of each element.">sqrt</a>((P_display - P_projected).colwise().squaredNorm().<a class="code" href="namespace_t_r_t_k_1_1_tools.html#a7dc4e90beeb8b34adeebc533dfa95e00" title="Returns the mean of all container elements.">mean</a>());
<a name="l01472"></a>01472                         <span class="keywordflow">return</span> rmse;
<a name="l01473"></a>01473                     }
<a name="l01474"></a>01474 
<a name="l01475"></a>01475                 <span class="keyword">public</span>:
<a name="l01476"></a>01476                     MatrixXT P_world;
<a name="l01477"></a>01477                     MatrixXT P_display;
<a name="l01478"></a>01478                     Matrix34T T_proj;
<a name="l01479"></a>01479                     Matrix4T T_pose;
<a name="l01480"></a>01480                 };
<a name="l01481"></a>01481 
<a name="l01482"></a>01482                 <span class="keyword">auto</span> func = ObjectiveFunction(P_world, P_display);
<a name="l01483"></a>01483                 cppoptlib::BfgsSolver&lt;ObjectiveFunction&gt; solver;
<a name="l01484"></a>01484                 solver.minimize(func, optimization_parameters);
<a name="l01485"></a>01485                 T_proj = func.T_proj;
<a name="l01486"></a>01486                 T_pose = func.T_pose;
<a name="l01487"></a>01487                 rmse = func.value(optimization_parameters);
<a name="l01488"></a>01488 
<a name="l01489"></a>01489                 <span class="keywordflow">break</span>;
<a name="l01490"></a>01490             }
<a name="l01491"></a>01491 
<a name="l01492"></a>01492             <span class="keywordflow">case</span> SAME_FOCAL_LENGTHS_AND_NO_SKEW:
<a name="l01493"></a>01493             {
<a name="l01494"></a>01494                 <span class="comment">// First decompose the camera matrix into the projection matrix and the pose matrix, respectively.</span>
<a name="l01495"></a>01495 
<a name="l01496"></a>01496                 VectorXT optimization_parameters;
<a name="l01497"></a>01497                 optimization_parameters.resize(9);
<a name="l01498"></a>01498 
<a name="l01499"></a>01499                 <span class="keywordflow">if</span> (constrained_decomposition)
<a name="l01500"></a>01500                 {
<a name="l01501"></a>01501                     <span class="comment">/*</span>
<a name="l01502"></a>01502 <span class="comment"></span>
<a name="l01503"></a>01503 <span class="comment">                    Decompose T_camera into T_proj and T_pose. While doing so, assume that f := f_x = f_y and tau = 0.</span>
<a name="l01504"></a>01504 <span class="comment">                    Since, these assumptions do no hold (due to noise, etc.), the below equation only provide some</span>
<a name="l01505"></a>01505 <span class="comment">                    rough estimates which are then used as the initial values for the non-linear optimization.</span>
<a name="l01506"></a>01506 <span class="comment"></span>
<a name="l01507"></a>01507 <span class="comment"></span>
<a name="l01508"></a>01508 <span class="comment">                    | T11  T12  T13  T14 |     | fx  tau  cx  0 |     | R  t |</span>
<a name="l01509"></a>01509 <span class="comment">                    | T21  T22  T23  T24 |  =  | 0   fy   cy  0 |  *  | 0  1 |</span>
<a name="l01510"></a>01510 <span class="comment">                    | T31  T32  T33  T34 |     | 0   0    1   0 |</span>
<a name="l01511"></a>01511 <span class="comment"></span>
<a name="l01512"></a>01512 <span class="comment">                         | T11  T12  T13 |     | T1^T |     | f  0  cx  |     | R1^T |</span>
<a name="l01513"></a>01513 <span class="comment">                    ==&gt;  | T21  T22  T23 |  =  | T2^T |  =  | 0  f  cy  |  *  | R2^T |          (***)</span>
<a name="l01514"></a>01514 <span class="comment">                         | T31  T32  T33 |     | T3^T |     | 0  0  1   |     | R3^T |</span>
<a name="l01515"></a>01515 <span class="comment"></span>
<a name="l01516"></a>01516 <span class="comment">                         f * R1 + cx * R3 = T1</span>
<a name="l01517"></a>01517 <span class="comment">                    ==&gt;  f * R2 + cy * R3 = T2</span>
<a name="l01518"></a>01518 <span class="comment">                         R3 = T3</span>
<a name="l01519"></a>01519 <span class="comment"></span>
<a name="l01520"></a>01520 <span class="comment">                    Normalize T with respect to the last row: T = T / || T3 ||.</span>
<a name="l01521"></a>01521 <span class="comment"></span>
<a name="l01522"></a>01522 <span class="comment">                    With some easy algebraic manipulations we have (R1, R2, and R3 are orthogonal to each other)</span>
<a name="l01523"></a>01523 <span class="comment"></span>
<a name="l01524"></a>01524 <span class="comment">                    cx = T3^T * T1</span>
<a name="l01525"></a>01525 <span class="comment">                    cy = T3^T * T2</span>
<a name="l01526"></a>01526 <span class="comment"></span>
<a name="l01527"></a>01527 <span class="comment">                    f * R1 = T1 - cx * T3</span>
<a name="l01528"></a>01528 <span class="comment">                    ==&gt;  f = || T1 - cx * T3 ||</span>
<a name="l01529"></a>01529 <span class="comment">                    ==&gt; R1 = (T1 - cx * T3) / f</span>
<a name="l01530"></a>01530 <span class="comment"></span>
<a name="l01531"></a>01531 <span class="comment">                    f * R2 = T2 - cy * T3</span>
<a name="l01532"></a>01532 <span class="comment">                    ==&gt;  f = || T2 - cy * T3 ||</span>
<a name="l01533"></a>01533 <span class="comment">                    ==&gt; R2 = (T2 - cy * T3) / f</span>
<a name="l01534"></a>01534 <span class="comment"></span>
<a name="l01535"></a>01535 <span class="comment">                    Both former computations for determining f may conflict with each other. Thus, we just</span>
<a name="l01536"></a>01536 <span class="comment">                    average both values of f. Also, R = [R1, R2, R3]^T is not necessarily orthogonal.</span>
<a name="l01537"></a>01537 <span class="comment"></span>
<a name="l01538"></a>01538 <span class="comment">                    */</span>
<a name="l01539"></a>01539 
<a name="l01540"></a>01540                     <span class="keyword">auto</span> T_camera = getCameraParameters();
<a name="l01541"></a>01541 
<a name="l01542"></a>01542                     T_camera /= T_camera.block&lt;1, 3&gt;(2, 0).norm(); <span class="comment">// the last row vector shall be a unit vector</span>
<a name="l01543"></a>01543                     Vector3T T1 = T_camera.block&lt;1, 3&gt;(0, 0);
<a name="l01544"></a>01544                     Vector3T T2 = T_camera.block&lt;1, 3&gt;(1, 0);
<a name="l01545"></a>01545                     Vector3T T3 = T_camera.block&lt;1, 3&gt;(2, 0);
<a name="l01546"></a>01546                     Vector3T R3 = T3;
<a name="l01547"></a>01547                     T cx = T3.transpose() * T1;
<a name="l01548"></a>01548                     T cy = T3.transpose() * T2;
<a name="l01549"></a>01549 
<a name="l01550"></a>01550                     T fx = (T1 - cx * T3).norm();
<a name="l01551"></a>01551                     Vector3T R1 = (T1 - cx * T3) / fx;
<a name="l01552"></a>01552 
<a name="l01553"></a>01553                     T fy = (T2 - cy * T3).norm();
<a name="l01554"></a>01554                     Vector3T R2 = (T2 - cy * T3) / fy;
<a name="l01555"></a>01555 
<a name="l01556"></a>01556                     T f = (fx + fy) / 2;
<a name="l01557"></a>01557 
<a name="l01558"></a>01558                     Matrix3T R;
<a name="l01559"></a>01559                     R.block&lt;1, 3&gt;(0, 0) = R1;
<a name="l01560"></a>01560                     R.block&lt;1, 3&gt;(1, 0) = R2;
<a name="l01561"></a>01561                     R.block&lt;1, 3&gt;(2, 0) = R3;
<a name="l01562"></a>01562 
<a name="l01563"></a>01563                     <span class="comment">// Orthogonalize R (guarantee right-handedness).</span>
<a name="l01564"></a>01564 
<a name="l01565"></a>01565                     <span class="keyword">auto</span> svd = JacobiSVD&lt;Matrix3T&gt;(R, ComputeFullU | ComputeFullV);
<a name="l01566"></a>01566                     R = svd.matrixU() * svd.matrixV().transpose();
<a name="l01567"></a>01567                     <span class="keywordflow">if</span> (R.determinant() &lt; 0) <span class="comment">// left-handed?</span>
<a name="l01568"></a>01568                     {
<a name="l01569"></a>01569                         MatrixXT D = MatrixXT::Identity(3, 3);
<a name="l01570"></a>01570                         D(2, 2) = -1;
<a name="l01571"></a>01571                         R = svd.matrixU() * D * svd.matrixV().transpose();
<a name="l01572"></a>01572                     }
<a name="l01573"></a>01573 
<a name="l01574"></a>01574                     <span class="comment">// Now, do the non-linear optimization. The RMSE is computed over the function (***)</span>
<a name="l01575"></a>01575                     <span class="comment">// where the rotation matrix is constructed from an axis-angle representation; the</span>
<a name="l01576"></a>01576                     <span class="comment">// unit axis is represented in spherical coordinates with only two angles/parameters.</span>
<a name="l01577"></a>01577                     <span class="comment">// Constructing a rotation matrix has the advantage that the orthogonality constraint</span>
<a name="l01578"></a>01578                     <span class="comment">// is always fulfilled.</span>
<a name="l01579"></a>01579 
<a name="l01580"></a>01580                     <span class="keyword">auto</span> [axis, rotation_angle] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a5c53f06f4479080bb50f489d83c4f8c8">axisAngleFromRotationMatrix</a>(R);
<a name="l01581"></a>01581                     <span class="keyword">auto</span> [__, axis_theta, axis_phi] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a35f674b6ab369c37820a9a3c3fbe5636">cartesian2Spherical</a>(axis.x(), axis.y(), axis.z());
<a name="l01582"></a>01582 
<a name="l01583"></a>01583                     optimization_parameters(0) = f;
<a name="l01584"></a>01584                     optimization_parameters(1) = cx;
<a name="l01585"></a>01585                     optimization_parameters(2) = cy;
<a name="l01586"></a>01586                     optimization_parameters(3) = axis_theta;
<a name="l01587"></a>01587                     optimization_parameters(4) = axis_phi;
<a name="l01588"></a>01588                     optimization_parameters(5) = rotation_angle;
<a name="l01589"></a>01589                     optimization_parameters(6) = this-&gt;getCameraPosition().x();
<a name="l01590"></a>01590                     optimization_parameters(7) = this-&gt;getCameraPosition().y();
<a name="l01591"></a>01591                     optimization_parameters(8) = this-&gt;getCameraPosition().z();
<a name="l01592"></a>01592                 }
<a name="l01593"></a>01593                 <span class="keywordflow">else</span>
<a name="l01594"></a>01594                 {
<a name="l01595"></a>01595                     Matrix3T R = T_pose.block&lt;3, 3&gt;(0, 0);
<a name="l01596"></a>01596                     <span class="keyword">auto</span> [axis, rotation_angle] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a5c53f06f4479080bb50f489d83c4f8c8">axisAngleFromRotationMatrix</a>(R);
<a name="l01597"></a>01597                     <span class="keyword">auto</span> [__, axis_theta, axis_phi] = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a35f674b6ab369c37820a9a3c3fbe5636">cartesian2Spherical</a>(axis.x(), axis.y(), axis.z());
<a name="l01598"></a>01598 
<a name="l01599"></a>01599                     optimization_parameters(0) = 0.5 * (T_proj(0, 0) + T_proj(1, 1));  <span class="comment">// f = (fx + fy) / 2</span>
<a name="l01600"></a>01600                     optimization_parameters(1) = T_proj(0, 2);  <span class="comment">// cx</span>
<a name="l01601"></a>01601                     optimization_parameters(2) = T_proj(1, 2);  <span class="comment">// cy</span>
<a name="l01602"></a>01602                     optimization_parameters(3) = axis_theta;
<a name="l01603"></a>01603                     optimization_parameters(4) = axis_phi;
<a name="l01604"></a>01604                     optimization_parameters(5) = rotation_angle;
<a name="l01605"></a>01605                     optimization_parameters(6) = T_pose(0, 3);  <span class="comment">// tx</span>
<a name="l01606"></a>01606                     optimization_parameters(7) = T_pose(1, 3);  <span class="comment">// ty</span>
<a name="l01607"></a>01607                     optimization_parameters(8) = T_pose(2, 3);  <span class="comment">// tz</span>
<a name="l01608"></a>01608                 }
<a name="l01609"></a>01609 
<a name="l01610"></a>01610                 <span class="comment">// Now compute the constrained optimization.</span>
<a name="l01611"></a>01611 
<a name="l01612"></a>01612                 <span class="keyword">class </span>ObjectiveFunction : <span class="keyword">public</span> cppoptlib::Problem&lt;double&gt;
<a name="l01613"></a>01613                 {
<a name="l01614"></a>01614                 <span class="keyword">public</span>:
<a name="l01615"></a>01615                     <span class="keyword">using</span> <span class="keyword">typename</span> cppoptlib::Problem&lt;double&gt;::Scalar;
<a name="l01616"></a>01616                     <span class="keyword">using</span> <span class="keyword">typename</span> cppoptlib::Problem&lt;double&gt;::TVector;
<a name="l01617"></a>01617 
<a name="l01618"></a>01618                     ObjectiveFunction(<span class="keyword">const</span> MatrixXT &amp; P_world, <span class="keyword">const</span> MatrixXT &amp; P_display)
<a name="l01619"></a>01619                     {
<a name="l01620"></a>01620                         this-&gt;P_world = P_world;
<a name="l01621"></a>01621                         this-&gt;P_display = P_display;
<a name="l01622"></a>01622                     }
<a name="l01623"></a>01623 
<a name="l01624"></a>01624                     <span class="keywordtype">double</span> value(<span class="keyword">const</span> TVector &amp; x)
<a name="l01625"></a>01625                     {
<a name="l01626"></a>01626                         T_proj = Matrix34T::Identity();
<a name="l01627"></a>01627                         T_proj(0, 0) = x(0);
<a name="l01628"></a>01628                         T_proj(1, 1) = x(0);
<a name="l01629"></a>01629                         T_proj(0, 2) = x(1);
<a name="l01630"></a>01630                         T_proj(1, 2) = x(2);
<a name="l01631"></a>01631 
<a name="l01632"></a>01632                         T_pose = Matrix4T::Identity();
<a name="l01633"></a>01633                         <span class="keyword">auto</span> axis = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#a231f96eb8d68e4058ea36be09cf118a0">spherical2Cartesian</a>(Vector3T(1, x(3), x(4)));
<a name="l01634"></a>01634                         T_pose.block&lt;3, 3&gt;(0, 0) = <a class="code" href="namespace_t_r_t_k_1_1_tools.html#ac2d049a7b10656584136d31bc2eb2f8a">rotationMatrix</a>(axis, x(5));
<a name="l01635"></a>01635                         T_pose(0, 3) = x(6);
<a name="l01636"></a>01636                         T_pose(1, 3) = x(7);
<a name="l01637"></a>01637                         T_pose(2, 3) = x(8);
<a name="l01638"></a>01638 
<a name="l01639"></a>01639                         <a class="code" href="namespace_t_r_t_k.html#ab6a8c5f73ab8b7638ca1011e6f2c89aa" title="Computes the square root of each element.">using ::sqrt</a>;
<a name="l01640"></a>01640                         MatrixXT T_camera = T_proj * T_pose;
<a name="l01641"></a>01641                         MatrixXT P_projected = (T_camera * P_world).colwise().hnormalized();
<a name="l01642"></a>01642                         T rmse = <a class="code" href="namespace_t_r_t_k.html#ab6a8c5f73ab8b7638ca1011e6f2c89aa" title="Computes the square root of each element.">sqrt</a>((P_display - P_projected).colwise().squaredNorm().<a class="code" href="namespace_t_r_t_k_1_1_tools.html#a7dc4e90beeb8b34adeebc533dfa95e00" title="Returns the mean of all container elements.">mean</a>());
<a name="l01643"></a>01643                         <span class="keywordflow">return</span> rmse;
<a name="l01644"></a>01644                     }
<a name="l01645"></a>01645 
<a name="l01646"></a>01646                 <span class="keyword">public</span>:
<a name="l01647"></a>01647                     MatrixXT P_world;
<a name="l01648"></a>01648                     MatrixXT P_display;
<a name="l01649"></a>01649                     Matrix34T T_proj;
<a name="l01650"></a>01650                     Matrix4T T_pose;
<a name="l01651"></a>01651                 };
<a name="l01652"></a>01652 
<a name="l01653"></a>01653                 <span class="keyword">auto</span> func = ObjectiveFunction(P_world, P_display);
<a name="l01654"></a>01654                 cppoptlib::BfgsSolver&lt;ObjectiveFunction&gt; solver;
<a name="l01655"></a>01655                 solver.minimize(func, optimization_parameters);
<a name="l01656"></a>01656                 T_proj = func.T_proj;
<a name="l01657"></a>01657                 T_pose = func.T_pose;
<a name="l01658"></a>01658                 rmse = func.value(optimization_parameters);
<a name="l01659"></a>01659 
<a name="l01660"></a>01660                 <span class="keywordflow">break</span>;
<a name="l01661"></a>01661             }
<a name="l01662"></a>01662 
<a name="l01663"></a>01663             <span class="keywordflow">default</span>:
<a name="l01664"></a>01664             {
<a name="l01665"></a>01665                 <a class="code" href="class_t_r_t_k_1_1_error_obj.html" title="Error class that incorporates additional information.">ErrorObj</a> error;
<a name="l01666"></a>01666                 error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a7581fa0d8725f2e6a9fc8412946898e0" title="Sets the class name (this should be the name of the class in which ErrorObj is thrown).">setClassName</a>(<span class="stringliteral">&quot;PinholeCameraModel&lt;T&gt;&quot;</span>);
<a name="l01667"></a>01667                 error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#aabb82023e284b6735162abe0feb5cc58" title="Sets the function name (this should be the name of the function in which ErrorObj is thrown)...">setFunctionName</a>(<span class="stringliteral">&quot;estimate&quot;</span>);
<a name="l01668"></a>01668                 error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a815faa194d64ee4fb969f213fc6d4a53" title="Sets the error message.">setErrorMessage</a>(<span class="stringliteral">&quot;Unknown estimation method.&quot;</span>);
<a name="l01669"></a>01669                 error.<a class="code" href="class_t_r_t_k_1_1_error_obj.html#a0a06daae496fb7007da711c44b84b1e7" title="Sets the error code.">setErrorCode</a>(UNKNOWN_ESTIMATION_METHOD);
<a name="l01670"></a>01670                 <span class="keywordflow">throw</span> error;
<a name="l01671"></a>01671             }
<a name="l01672"></a>01672 
<a name="l01673"></a>01673         } <span class="comment">// switch(method)</span>
<a name="l01674"></a>01674 
<a name="l01675"></a>01675 
<a name="l01676"></a>01676         <span class="keywordflow">return</span> rmse;
<a name="l01677"></a>01677     }
<a name="l01678"></a>01678 
<a name="l01679"></a>01679 <span class="preprocessor">#endif // CPPOPTLIB_FOUND</span>
<a name="l01680"></a>01680 <span class="preprocessor"></span>
<a name="l01681"></a>01681 
<a name="l01682"></a>01682     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01683"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#ab2f756bb6f61bd026b64caca003b5283">01683</a>     <span class="keyword">typename</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::Matrix34T</a> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::getCameraParameters</a>()<span class="keyword"> const</span>
<a name="l01684"></a>01684 <span class="keyword">    </span>{
<a name="l01685"></a>01685         <span class="keywordflow">return</span> T_proj * T_pose;
<a name="l01686"></a>01686     }
<a name="l01687"></a>01687 
<a name="l01688"></a>01688 
<a name="l01689"></a>01689     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01690"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#af4c80fc147e039efd019fa016ef100b8">01690</a>     <span class="keyword">typename</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::Matrix3T</a> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::getCameraOrientation</a>()<span class="keyword"> const</span>
<a name="l01691"></a>01691 <span class="keyword">    </span>{
<a name="l01692"></a>01692         <span class="keywordflow">return</span> T_pose.block&lt;3, 3&gt;(0, 0);
<a name="l01693"></a>01693     }
<a name="l01694"></a>01694 
<a name="l01695"></a>01695 
<a name="l01696"></a>01696     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01697"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#aa84e1080b86ecd21bb48874c2b2b42b9">01697</a>     <span class="keyword">typename</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::Vector3T</a> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::getCameraPosition</a>()<span class="keyword"> const</span>
<a name="l01698"></a>01698 <span class="keyword">    </span>{
<a name="l01699"></a>01699         <span class="keywordflow">return</span> T_pose.block&lt;3, 1&gt;(0, 3);
<a name="l01700"></a>01700     }
<a name="l01701"></a>01701 
<a name="l01702"></a>01702 
<a name="l01703"></a>01703     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01704"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a6aa7d094ea0427bb0321285513a2a40e">01704</a>     <span class="keyword">typename</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::Matrix4T</a> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::getExtrinsicParameters</a>()<span class="keyword"> const</span>
<a name="l01705"></a>01705 <span class="keyword">    </span>{
<a name="l01706"></a>01706         <span class="keywordflow">return</span> T_pose;
<a name="l01707"></a>01707     }
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 
<a name="l01710"></a>01710     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01711"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a48f9a7a5f41045677ae7e0d6ad1f1e8f">01711</a>     std::tuple&lt;T, T&gt; <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::getFocalLengths</a>()<span class="keyword"> const</span>
<a name="l01712"></a>01712 <span class="keyword">    </span>{
<a name="l01713"></a>01713         <span class="keywordflow">return</span> std::make_tuple(T_proj(0, 0), T_proj(1, 1));
<a name="l01714"></a>01714     }
<a name="l01715"></a>01715 
<a name="l01716"></a>01716 
<a name="l01717"></a>01717     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01718"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#ad8aad65bde8557631a754b57712330fb">01718</a>     std::tuple&lt;T, T&gt; <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::getImageCenter</a>()<span class="keyword"> const</span>
<a name="l01719"></a>01719 <span class="keyword">    </span>{
<a name="l01720"></a>01720         <span class="keywordflow">return</span> std::make_tuple(T_proj(0, 2), T_proj(1, 2));
<a name="l01721"></a>01721     }
<a name="l01722"></a>01722 
<a name="l01723"></a>01723 
<a name="l01724"></a>01724     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01725"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a6fd4203805063e5dc042f1ce6bf11ce5">01725</a>     <span class="keyword">typename</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::Matrix34T</a> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::getIntrinsicParameters</a>()<span class="keyword"> const</span>
<a name="l01726"></a>01726 <span class="keyword">    </span>{
<a name="l01727"></a>01727         <span class="keywordflow">return</span> T_proj;
<a name="l01728"></a>01728     }
<a name="l01729"></a>01729 
<a name="l01730"></a>01730 
<a name="l01731"></a>01731     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01732"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a7d5d0b85b38ba20d38f85a50c34a61ab">01732</a>     T <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::getSkew</a>()<span class="keyword"> const</span>
<a name="l01733"></a>01733 <span class="keyword">    </span>{
<a name="l01734"></a>01734         <span class="keywordflow">return</span> T_proj(0, 1);
<a name="l01735"></a>01735     }
<a name="l01736"></a>01736 
<a name="l01737"></a>01737 
<a name="l01738"></a>01738     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01739"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a3fbe9317edc7f97751fb1fda32b8d79d">01739</a>     <span class="keyword">typename</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::Vector2T</a> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::operator*</a>(<span class="keyword">const</span> Vector3T &amp; point)<span class="keyword"> const</span>
<a name="l01740"></a>01740 <span class="keyword">    </span>{
<a name="l01741"></a>01741         <span class="keywordflow">return</span> transform(point);
<a name="l01742"></a>01742     }
<a name="l01743"></a>01743 
<a name="l01744"></a>01744 
<a name="l01745"></a>01745     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01746"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a556a857e79aa588edb1af3a2893d13cf">01746</a>     <span class="keyword">typename</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::Vector2T</a> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::transform</a>(<span class="keyword">const</span> Vector3T &amp; point)<span class="keyword"> const</span>
<a name="l01747"></a>01747 <span class="keyword">    </span>{
<a name="l01748"></a>01748         <span class="keywordflow">return</span> (T_proj * T_pose * point.homogeneous()).hnormalized();
<a name="l01749"></a>01749     }
<a name="l01750"></a>01750 
<a name="l01751"></a>01751 
<a name="l01752"></a>01752     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01753"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a78dc059244a8fbee9efcbe4c1bc0a514">01753</a>     <span class="keywordtype">void</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::setCameraOrientation</a>(<span class="keyword">const</span> Matrix3T &amp; orientation)
<a name="l01754"></a>01754     {
<a name="l01755"></a>01755         assert((orientation * orientation.transpose() - Matrix3T::Identity()).norm() &lt; 1e-7); <span class="comment">// orthogonal?</span>
<a name="l01756"></a>01756         <span class="comment">// assert(abs(orientation.determinant() - 1) &lt; 1e-7); // right-handed without scaling? &lt;-- nope, we should not unnecessarily restrict the mapping</span>
<a name="l01757"></a>01757 
<a name="l01758"></a>01758         T_pose.block&lt;3, 3&gt;(0, 0) = orientation;
<a name="l01759"></a>01759     }
<a name="l01760"></a>01760 
<a name="l01761"></a>01761 
<a name="l01762"></a>01762     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01763"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a5621519e5fe03c3669c21f322be9830e">01763</a>     <span class="keywordtype">void</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::setCameraPosition</a>(<span class="keyword">const</span> Vector3T &amp; position)
<a name="l01764"></a>01764     {
<a name="l01765"></a>01765         T_pose.block&lt;3, 1&gt;(0, 3) = position;
<a name="l01766"></a>01766     }
<a name="l01767"></a>01767 
<a name="l01768"></a>01768 
<a name="l01769"></a>01769     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01770"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a84230ab40f0eba76140a7b1c8038cfaa">01770</a>     <span class="keywordtype">void</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::setExtrinsicParameters</a>(<span class="keyword">const</span> Matrix4T &amp; parameters)
<a name="l01771"></a>01771     {
<a name="l01772"></a>01772         <span class="keyword">auto</span> &amp; R = parameters.block&lt;3, 3&gt;(0, 0);
<a name="l01773"></a>01773         <span class="keyword">const</span> <span class="keywordtype">bool</span> ORIENTATION_MATRIX_IS_ORTHOGONAL = ((R * R.transpose()) - Matrix3T::Identity()).norm() &lt; 1e-7;
<a name="l01774"></a>01774         assert(ORIENTATION_MATRIX_IS_ORTHOGONAL);
<a name="l01775"></a>01775 
<a name="l01776"></a>01776         T_pose = parameters;
<a name="l01777"></a>01777     }
<a name="l01778"></a>01778 
<a name="l01779"></a>01779 
<a name="l01780"></a>01780     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01781"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a1d5249862e429a99558d04356da83c84">01781</a>     <span class="keywordtype">void</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::setFocalLengths</a>(T f_x, T f_y)
<a name="l01782"></a>01782     {
<a name="l01783"></a>01783         T_proj(0, 0) = f_x;
<a name="l01784"></a>01784         T_proj(1, 1) = f_y;
<a name="l01785"></a>01785     }
<a name="l01786"></a>01786 
<a name="l01787"></a>01787 
<a name="l01788"></a>01788     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01789"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#ad7c09afa15fb705b30feb92cfdee24d9">01789</a>     <span class="keywordtype">void</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::setImageCenter</a>(T c_x, T c_y)
<a name="l01790"></a>01790     {
<a name="l01791"></a>01791         T_proj(0, 2) = c_x;
<a name="l01792"></a>01792         T_proj(1, 2) = c_y;
<a name="l01793"></a>01793     }
<a name="l01794"></a>01794 
<a name="l01795"></a>01795 
<a name="l01796"></a>01796     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01797"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#ad449542e46ce7281f3832019af22f9c7">01797</a>     <span class="keywordtype">void</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::setIntrinsicParameters</a>(<span class="keyword">const</span> Matrix34T &amp; parameters)
<a name="l01798"></a>01798     {
<a name="l01799"></a>01799         T_proj = parameters;
<a name="l01800"></a>01800     }
<a name="l01801"></a>01801 
<a name="l01802"></a>01802 
<a name="l01803"></a>01803     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l01804"></a><a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html#a06243156b3b95985f2df323cb0d73b58">01804</a>     <span class="keywordtype">void</span> <a class="code" href="class_t_r_t_k_1_1_pinhole_camera_model.html" title="A simple pinhole camera model.">PinholeCameraModel&lt;T&gt;::setSkew</a>(T skew)
<a name="l01805"></a>01805     {
<a name="l01806"></a>01806         T_proj(0, 1) = skew;
<a name="l01807"></a>01807     }
<a name="l01808"></a>01808 
<a name="l01809"></a>01809 
<a name="l01810"></a>01810 } <span class="comment">// namespace TRTK</span>
<a name="l01811"></a>01811 
<a name="l01812"></a>01812 
<a name="l01813"></a>01813 <span class="preprocessor">#endif // PINHOLE_CAMERA_MODEL_HPP_4231789408</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/>
    <address class="footer">
        <small>
            Copyright 2010 - 2019 by Christoph HÃ¤nisch,
            Chair of Medical Engineering (mediTEC),
            RWTH Aachen University <p>
            Documentation generated by <a href="http://www.doxygen.org/index.html"> Doxygen </a>
        </small>
    </address>

</body>
</html>
